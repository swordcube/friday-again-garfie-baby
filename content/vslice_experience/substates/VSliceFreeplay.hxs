// TODO: figure out how to properly optimize capsule updating
// removing the code brings the up to 700fps, with updating it drops to 200fps

// TODO: add difficulty dots from the 0.7 update
// TODO: add dj easter eggs

import openfl.geom.Point;
import openfl.geom.Matrix;

import openfl.display.BitmapData;
import openfl.geom.ColorTransform;

import openfl.filters.BlurFilter;
import openfl.filters.GlowFilter;

import openfl.media.Sound;

import flixel.graphics.FlxGraphic;
import animate.internal.FilterRenderer;

import funkin.backend.Main;
import funkin.scripting.FunkinScript;

import funkin.states.TransitionableState;
import funkin.states.editors.ChartEditor;
import funkin.states.menus.FreeplayState.FreeplaySongData;

import funkin.substates.ResetScoreSubState;
import funkin.substates.GameplayModifiersMenu;

import funkin.utilities.MemoryUtil;

final ext:String = "menus/freeplay/";

final songNameSelectColor:FlxColor = 0xFFFFFFFF;
final songNameDeselectColor:FlxColor = 0xFF969A9D;
final songNameSelectBorderColor:FlxColor = 0xFF6B9FBA;
final songNameDeselectBorderColor:FlxColor = 0xFF3E508C;

var parent:MainMenuState;

// makin several groups for each part of
// the song capsules, for better batching
var capsuleData = {
    offsetX: 0.0
};
var grpCapsules:FlxTypedGroup<TrackingSprite>;
var grpSongNames:FlxTypedGroup<TrackingSprite>;

var grpSongIcons:FlxTypedGroup<TrackingSprite>;
var grpCapsuleExtras:FlxTypedGroup<TrackingSprite>;

var capsuleSmallNumbers:Array<Array<TrackingSprite>> = [];
var capsuleBigNumbers:Array<Array<TrackingSprite>> = [];

var capsuleIcons:Array<Array<TrackingSprite>> = [];
var capsuleBadges:Array<Array<TrackingSprite>> = [];

// groups for category stuff!
var grpCategoryArrows:FlxTypedSpriteGroup<FunkinSprite>;
var grpCategorySeparators:FlxTypedSpriteGroup<FunkinSprite>;
var grpCategories:FlxTypedSpriteGroup<FunkinSprite>;

var diffDisplay:FunkinSprite;
var diffLeftSelector:FunkinSprite;
var diffRightSelector:FunkinSprite;

var categoryLeftArrow:FunkinSprite;
var categoryRightArrow:FunkinSprite;

// taken straight from garfie baby source code
var categories:Array<FreeplayCategory> = [];
var categoryMap:Map<String, FreeplayCategory> = ["" => null];

var songs:Array<VSliceFreeplaySongData> = [];
var songListMap:Map<String, Array<VSliceFreeplaySongData>> = ["" => null];

var curCharacter:String;
var songFilters:Array<String> = [
    "#", // only songs that contain numbers in their title?? i think??
    "fav", // favorited songs
    "ALL", // all songs
    "AB", // only songs that contain A or B in their title
    "CD", // only songs that contain C or D in their title
    "EH", // only songs that contain E or H in their title
    "IL", // only songs that contain I or L in their title
    "MN", // only songs that contain M or N in their title
    "OR", // only songs that contain O or R in their title
    "S", // only songs that contain S in their title
    "T", // only songs that contain T in their title
    "UZ", // only songs that contain U or Z in their title
];
var accessibleSongs:Array<VSliceFreeplaySongData> = [];

// key is songName:songMix:difficulty:contentPack
var songScoreRecords:Map<String, ScoreRecord> = ["" => null]; 

var pinkBG:FlxSprite;
var dadCover:FlxSprite;

var albumCover:FunkinSprite;

var albumTitle:FunkinSprite;
var albumTitleShader:ColorGradientShader;

var difficultyStars:DifficultyStars;

var curSelected:Int = 1;
var curSongFilter:Int = 2;

var currentDifficulty:String = "normal";
var currentMix:String = "default";

var lastDifficulty:String = "normal";
var lastMix:String = "default";

var currentAlbum:String = "vol1";
var lastAlbum:String = "vol1";

var accepted:Bool = false;
var goMyFreeplay:Bool = false;

var header:FunkinSprite;
var headerFreeplayText:FlxText;
var headerOSTText:FlxText;

var dj:FunkinSprite;
var djScript:FunkinScript;

var clearBox:FunkinSprite;
var percentDisplay:DigitDisplay;
var scoreDisplay:DigitDisplay;
var highScoreText:FunkinSprite;

var totalTime:Float = 0;
var busy:Bool = true;

var badgeBlurs:Array<CustomShader> = [
    new CustomShader("blur"), // 1 amount, used for rank badges
    new CustomShader("blur"), // 1.2 amount, used for favorite badges
];
badgeBlurs[0].setFloat("amount", 1);
badgeBlurs[1].setFloat("amount", 1.2);

var loadedSongs:Map<String, BGMData> = ["" => null];
var currentBGM:String = null;

var blur:BlurFilter = new BlurFilter();
var optimizeCapsuleUpdating:Bool = false;

var flickerState:Int = 0;
var cachedOpponentMode:Bool = null;

var instPreviewTimer:FlxTimer = null;

function new(_parent:MainMenuState, ?menuSkin:String) {
    parent = _parent;
    curCharacter = menuSkin ?? "bf";
}

function addSongsToCategory(categoryID:String, ?songIDs:Array<String>, ?contentPack:String, ?priority:Int):Void {
    priority ??= 0;

    if(contentPack == null)
        contentPack = Paths.forceContentPack;

    if(songIDs == null || songIDs.length == 0)
        return;

    var songList:Array<FreeplaySongData> = songListMap.get('${contentPack}:${categoryID}');
    if(songList == null) {
        songList = [];
        songListMap.set('${contentPack}:${categoryID}', songList);
    }
    for(song in songIDs) {
        final defaultMetadata:SongMetadata = SongMetadata.load(song, null, contentPack);
        final metadataMap:Map<String, SongMetadata> = ["default" => defaultMetadata];
        
        for(mix in defaultMetadata.song.mixes)
            metadataMap.set(mix, SongMetadata.load(song, mix, contentPack));

        final difficultyMap:Map<String, Array<String>> = ["default" => defaultMetadata.song.difficulties];
        for(metadata in metadataMap) {
            for(mix in metadata.song.mixes)
                difficultyMap.set(mix, metadataMap.get(mix).song.difficulties);
        }
        for(mix => diffs in difficultyMap) {
            for(diff in diffs) {
                final recordID:String = Highscore.getScoreRecordID(song, diff, mix, contentPack);
                songScoreRecords.set('${song}:${mix}:${diff}:${contentPack}', Highscore.getScoreRecord(recordID));

                final recordIDOpponentMode:String = Highscore.getScoreRecordID(song, diff, mix, contentPack, true);
                songScoreRecords.set('${song}:${mix}:${diff}:${contentPack}:opponent', Highscore.getScoreRecord(recordIDOpponentMode));
            }
        }
        final songData:VSliceFreeplaySongData = {
            metadata: metadataMap,
            id: song,
            difficulties: difficultyMap,
            contentPack: contentPack
        };
        songs.insert(songs.length - priority, songData);
        songList.insert(songList.length - priority, songData);
    }
}

function regenCapsules(filter:String) {
    var songsToFilter:Array<VSliceFreeplaySongData> = songs.filter((song:VSliceFreeplaySongData) -> {
        return song.metadata.exists(currentMix);
    });
    var filteredSongs:Array<VSliceFreeplaySongData> = null;
    switch(filter) {
        case "#":
            final nums:String = "0123456789";
            filteredSongs = songsToFilter.filter((data:VSliceFreeplaySongData) -> {
                final meta:SongMetadata = data.metadata.get("default");
                for(i in 0...nums.length) {
                    if(meta != null && StringTools.contains(meta.song.title, nums.charAt(i)))
                        return true;
                }
                return false;
            });

        case "fav":
            filteredSongs = songsToFilter.filter((data:VSliceFreeplaySongData) -> {
                return isSongFavorited(data.id, data.contentPack);
            });
        
        case "ALL":
            filteredSongs = songsToFilter;

        default:
            if(filter.length == 1) {
                // handle "S" and "T" categories
                filteredSongs = songsToFilter.filter((data:FreeplaySongData) -> {
                    final meta:SongMetadata = data.metadata.get("default");
                    return meta != null && StringTools.contains(meta.song.title, filter);
                });
            } else {
                // handle the two-lettered categories
                filteredSongs = songsToFilter.filter((data:FreeplaySongData) -> {
                    final meta:SongMetadata = data.metadata.get("default");
                    return meta != null && (StringTools.contains(meta.song.title, filter.charAt(0)) || StringTools.contains(meta.song.title, filter.charAt(1)));
                });
            }
    }
    filteredSongs.insert(0, {metadata: null, id: "CUSTOM://random", difficulties: null, contentPack: null});
    accessibleSongs = filteredSongs;

    for(grp in [grpCapsules, grpSongNames, grpSongIcons, grpCapsuleExtras]) {
        while(grp.length > 0) {
            final memb = grp.members[0];
            grp.remove(memb, true);
            memb.destroy();
        }
    }
    capsuleIcons = [];
    capsuleBadges = [];
    capsuleSmallNumbers = [];
    capsuleBigNumbers = [];
    
    for(i in 0...filteredSongs.length) {
        // get song metadata
        final songData:FreeplaySongData = filteredSongs[i];
        final songMeta:SongMetadata = (songData.metadata != null) ? songData.metadata.get(currentMix) : null;

        var displayedName:String = null;
        switch(songData.id) {
            case "CUSTOM://random":
                displayedName = "Random";

            default:
                displayedName = songMeta.song.title;
        }

        // make capsule base
        final capsule:FunkinSprite = new FunkinSprite().loadSparrowFrames('${ext}skins/${curCharacter}/capsule');
        capsule.anim.addByPrefix('idle', 'mp3 capsule w backing NOT SELECTED0', 24, true);
        capsule.anim.addByPrefix('selected', 'mp3 capsule w backing0', 24, true);
        capsule.anim.setOffset('selected', 4, 0);
        capsule.anim.play('idle');
        capsule.setPosition(335 + Math.sin((i - curSelected) + 1) * 60 + FlxG.width, -200 + ((i - curSelected) * 115));
        capsule.setScale(0.8, FlxAxes.XY);
        capsule.extra.set("doLerp", true);
        Reflect.setProperty(capsule, "ID", i); // rulescript.
        grpCapsules.add(capsule);

        // make capsule text

        // WARNING: this is kinda of a hack, i'm making an FlxText
        // to generate the song name graphic, then using that graphic
        // on a TrackingSprite. kinda stupid i know
        final textGraphic:FlxText = new FlxText(0, 0, 0, displayedName);
        textGraphic.setFormat(Paths.font("fonts/5by7"), 32, songNameSelectColor);
        textGraphic.color = 0xFF00CCFF;
        textGraphic.regenGraphic();
        
        // generate the blurred part of the text
        final textGlowBitmap:BitmapData = new BitmapData(textGraphic.pixels.width + 12, textGraphic.pixels.height + 12, true, FlxColor.TRANSPARENT);
        final bmd1:BitmapData = new BitmapData(textGlowBitmap.width, textGlowBitmap.height, true, FlxColor.TRANSPARENT);
        FilterRenderer.__applyFilter(textGlowBitmap, bmd1, null, textGraphic.pixels, [blur], new Point(6, 6));
        
        textGraphic.color = FlxColor.WHITE;
        textGraphic.regenGraphic();
        
        final textFlashGlowBitmap:BitmapData = new BitmapData(textGraphic.pixels.width + 12, textGraphic.pixels.height + 12, true, FlxColor.TRANSPARENT);
        final bmd1:BitmapData = new BitmapData(textFlashGlowBitmap.width, textFlashGlowBitmap.height, true, FlxColor.TRANSPARENT);
        FilterRenderer.__applyFilter(textFlashGlowBitmap, bmd1, null, textGraphic.pixels, [blur], new Point(6, 6));
        
        final matrix:Matrix = new Matrix();
        
        final ct:ColorTransform = new ColorTransform();
        ct.alphaMultiplier = 0.45;

        textFlashGlowBitmap.draw(textFlashGlowBitmap, matrix, ct);
        textFlashGlowBitmap.draw(textFlashGlowBitmap, matrix, ct);

        // make the text white and regen graphic
        // textGraphic.color = FlxColor.WHITE;
        // textGraphic.regenGraphic();
        
        // then draw that on-top of the blurred text
        // basically giving it a glow effect
        matrix.translate(6, 6);
        textGlowBitmap.draw(textGraphic.pixels, matrix);
        textFlashGlowBitmap.draw(textGraphic.pixels, matrix);

        // then finally, use that bitmap on a sprite
        final text:TrackingSprite = new TrackingSprite();
        text.loadGraphic(FlxGraphic.fromBitmapData(textFlashGlowBitmap)); // stuff this into flixel cache so it will be auto-destroyed later!
        text.loadGraphic(FlxGraphic.fromBitmapData(textGlowBitmap));
        text.tracked = capsule;
        text.trackingMode = 4; // 4 = DIRECT
        text.trackingOffset.set(88, 26);
        text.copyAlpha = false;
        text.clipRect = new FlxRect();
        text.extra.set("bitmaps", [textGlowBitmap, textFlashGlowBitmap]);
        Reflect.setProperty(text, "ID", i);
        // text.kill();
        text.update(0);
        grpSongNames.add(text);

        // add the bpm & difficulty display shit
        final smallNumbers:Array<TrackingSprite> = [];
        final bigNumbers:Array<TrackingSprite> = [];
        
        if(songData.id != "CUSTOM://random") {
            final bpmLabel:TrackingSprite = new TrackingSprite().loadGraphic(Paths.image('menus/freeplay/capsule/bpm_text'));
            bpmLabel.tracked = capsule;
            bpmLabel.trackingMode = 4; // 4 = DIRECT
            bpmLabel.trackingOffset.set(82, 75);
            bpmLabel.setScale(0.9, FlxAxes.XY);
            grpCapsuleExtras.add(bpmLabel);

            for(i in 0...3) {
                final smallNumber:TrackingSprite = new TrackingSprite();
                smallNumber.loadSparrowFrames('menus/freeplay/capsule/small_numbers');
    
                for(i => str in ["ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE"])
                    smallNumber.anim.addByPrefix(Std.string(i), str, 0, false);
                
                smallNumber.anim.play("0");
                smallNumber.tracked = capsule;
                smallNumber.trackingMode = 4; // 4 = DIRECT
                smallNumber.trackingOffset.set(125 + (i * 11), 75);
                smallNumber.setScale(0.9, FlxAxes.XY);
                grpCapsuleExtras.add(smallNumber);
    
                smallNumbers.push(smallNumber);
            }
            final difficultyLabel:TrackingSprite = new TrackingSprite().loadGraphic(Paths.image('menus/freeplay/capsule/difficulty_text'));
            difficultyLabel.tracked = capsule;
            difficultyLabel.trackingMode = 4; // 4 = DIRECT
            difficultyLabel.trackingOffset.set(354, 75);
            difficultyLabel.setScale(0.9, FlxAxes.XY);
            grpCapsuleExtras.add(difficultyLabel);

            for(i in 0...2) {
                final bigNumber:TrackingSprite = new TrackingSprite();
                bigNumber.loadSparrowFrames('menus/freeplay/capsule/big_numbers');
    
                for(i => str in ["ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE"])
                    bigNumber.anim.addByPrefix(Std.string(i), str, 0, false);
                
                bigNumber.anim.play("0");
                bigNumber.tracked = capsule;
                bigNumber.trackingMode = 4; // 4 = DIRECT
                bigNumber.trackingOffset.set(400 + (i * 30), 18);
                bigNumber.setScale(0.9, FlxAxes.XY);
                grpCapsuleExtras.add(bigNumber);
    
                bigNumbers.push(bigNumber);
            }
            var weekID:Int = 0;
            var weekCounter:Int = 0;

            var isWeekend:Bool = false;
            for(level in Paths.contentMetadata.get(songData.contentPack).levels) {
                if(level.songs.contains(songData.id)) {
                    isWeekend = StringTools.startsWith(level.id, "weekend");
                    if(isWeekend) {
                        if(weekCounter > 0) weekCounter = -1;
                        weekID = Std.int(Math.abs(weekCounter));
                    } else
                        weekID = weekCounter;
                    
                    break;
                }
                if(isWeekend)
                    weekCounter--;
                else
                    weekCounter++;
            }
            if(weekID != 0) {
                final weekLabel:TrackingSprite = new TrackingSprite();
                weekLabel.loadSparrowFrames('menus/freeplay/capsule/week_types');
                weekLabel.anim.addByPrefix('week', 'WEEK0', 0, false);
                weekLabel.anim.addByPrefix('weekend', 'WEEKEND0', 0, false);
                weekLabel.anim.play("week");
                weekLabel.tracked = capsule;
                weekLabel.trackingMode = 4; // 4 = DIRECT
                weekLabel.trackingOffset.set(230, 75);
                weekLabel.setScale(0.9, FlxAxes.XY);
                grpCapsuleExtras.add(weekLabel);

                final weekNumber:TrackingSprite = new TrackingSprite();
                weekNumber.loadSparrowFrames('menus/freeplay/capsule/small_numbers');
    
                for(i => str in ["ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE"])
                    weekNumber.anim.addByPrefix(Std.string(i), str, 0, false);
                
                weekNumber.anim.play(Std.string(weekID));
                weekNumber.tracked = capsule;
                weekNumber.trackingMode = 4; // 4 = DIRECT
                weekNumber.trackingOffset.set(195 + ((weekLabel.anim.name == "weekend") ? 133 : 96), 75);
                weekNumber.setScale(0.9, FlxAxes.XY);
                grpCapsuleExtras.add(weekNumber);
            }
        }
        capsuleSmallNumbers.push(smallNumbers);
        capsuleBigNumbers.push(bigNumbers);

        // make the character icon for this song
        var chosenIcon:String = "face";
        if(songMeta != null && songMeta.freeplay.icon != null)
            chosenIcon = songMeta.freeplay.icon;

        if(songData.id == "CUSTOM://random")
            chosenIcon = "none"; // hardcoded i don't care
        
        if(chosenIcon != "none") {
            var iconJsonPath:String = Paths.json('menus/freeplay/icons/${chosenIcon}');
            if(!FlxG.assets.exists(iconJsonPath))
                iconJsonPath = Paths.json('menus/freeplay/icons/face');
            
            final iconConfig:Dynamic = (FlxG.assets.exists(iconJsonPath)) ? Json.parse(FlxG.assets.getText(iconJsonPath)) : {offset: [0, 0]};

            final songIcon:TrackingSprite = new TrackingSprite();
            songIcon.tracked = capsule;
            songIcon.trackingMode = 4; // 4 = DIRECT
            songIcon.trackingOffset.set(iconConfig.offset[0] - 4, iconConfig.offset[1] - 2);

            if(FlxG.assets.exists(Paths.image('menus/freeplay/icons/${chosenIcon}')))
                songIcon.loadSparrowFrames('menus/freeplay/icons/${chosenIcon}');
            else
                songIcon.loadSparrowFrames('menus/freeplay/icons/face');
            
            songIcon.anim.addByPrefix('idle', 'idle', 12, true);
            songIcon.anim.addByPrefix('confirm', 'confirm0', 12, false);
            songIcon.anim.play('idle');
            songIcon.antialiasing = false;
            songIcon.setScale(2, FlxAxes.XY);
            Reflect.setProperty(songIcon, "ID", i); // rulescript.
            grpSongIcons.add(songIcon);
            capsuleIcons.push(songIcon);
        } else
            capsuleIcons.push(null);

        // make the rank badge (along with it's sparkle ifit's a golden P rank)
        function initRankBadge(b:TrackingSprite) {
            b.tracked = capsule;
            b.trackingMode = 4; // 4 = DIRECT
            b.trackingOffset.set(356, 28);
            b.copyAlpha = false;
            b.loadSparrowFrames('menus/freeplay/rank_badges');
            
            for(rank in Highscore.ALL_RANKS) {
                if(rank == "unknown") continue; // skip this one
                b.anim.addByPrefix(rank, '${rank.toUpperCase()} rank', 24, false);
            }
            b.anim.play('loss');
            b.anim.finish();
            b.setScale(0.9, FlxAxes.XY);
            Reflect.setProperty(b, "ID", i); // rulescript.
        }
        final rankBadgeBlurred:TrackingSprite = new TrackingSprite();
        initRankBadge(rankBadgeBlurred);
        rankBadgeBlurred.shader = badgeBlurs[0];
        grpCapsuleExtras.add(rankBadgeBlurred);

        final rankBadge:TrackingSprite = new TrackingSprite();
        initRankBadge(rankBadge);
        rankBadge.extra.set("blurredBadge", rankBadgeBlurred);
        grpCapsuleExtras.add(rankBadge);
        
        var key:String = '${songData.id}:${currentMix}:${currentDifficulty}:${songData.contentPack}';
        if(cachedOpponentMode)
            key += ":opponent";

        final scoreRecord:ScoreRecord = songScoreRecords.get(key);
        rankBadge.exists = rankBadgeBlurred.exists = scoreRecord != null && scoreRecord.rank != "unknown";

        if(rankBadge.exists) {
            rankBadgeBlurred.anim.play(scoreRecord.rank);
            rankBadgeBlurred.anim.finish();

            rankBadge.anim.play(scoreRecord.rank);
            rankBadge.anim.finish();
        }
        // make the favorite badge
        function initFavBadge(b:TrackingSprite) {
            b.tracked = capsule;
            b.trackingMode = 4; // 4 = DIRECT
            b.trackingOffset.set(316, 22);
            b.copyAlpha = false;
            b.loadSparrowFrames('menus/freeplay/favorite');
            b.anim.addByPrefix('fav', 'favorite heart', 24, false);
            b.anim.addByPrefix('unfav', 'favorite heart', 24, false);
            b.anim.play('fav');
            b.anim.finish();
            b.setGraphicSize(50, 50);
            b.updateHitbox();
            b.anim.onFinish.add((name:String) -> {
                if(name == "unfav")
                    b.exists = false;
            });
            b.frameOffset.x = 5;
            Reflect.setProperty(b, "ID", i); // rulescript.
        }
        final favBadgeBlurred:TrackingSprite = new TrackingSprite();
        initFavBadge(favBadgeBlurred);
        favBadgeBlurred.shader = badgeBlurs[1];
        favBadgeBlurred.exists = isSongFavorited(songData.id, songData.contentPack);
        grpCapsuleExtras.add(favBadgeBlurred);
        
        final favBadge:TrackingSprite = new TrackingSprite();
        initFavBadge(favBadge);
        favBadge.extra.set("blurredBadge", favBadgeBlurred);
        favBadge.exists = favBadgeBlurred.exists;
        grpCapsuleExtras.add(favBadge);

        capsuleBadges.push([rankBadge, favBadge]);
        
        // we don't need the text object from earlier anymore,
        // KILL IT WITH FIRE ðŸ”¥ðŸ”¥ðŸ”¥
        textGraphic.destroy();
    }
}

function updateAlbumDisplay():Void {
    albumCover.visible = curSelected > 0;
    albumTitle.visible = curSelected > 0;
    difficultyStars.grp.visible = curSelected > 0;
    
    if(curAlbum == lastAlbum)
        return;

    if(curAlbum != null) {
        albumCover.loadGraphic(Paths.image('menus/freeplay/album/${curAlbum}/album'));
        albumTitle.loadGraphic(Paths.image('menus/freeplay/album/${curAlbum}/title'));

        difficultyStars.stars.y = difficultyStars.grp.y + 5;
        
        for(i in 0...difficultyStars.flames.length) {
            final flame:FlxSprite = difficultyStars.flames.members[i];
            flame.frameOffset.y = -5;
        }
        albumCover.frameOffset.y = -5;
        albumTitle.frameOffset.y = -5;

        albumCover.visible = true;
        albumTitle.visible = true;

        difficultyStars.visible = true;
        albumTitleShader.setBlackColor(0xFF4B97F3);
        
        FlxTimer.wait(0.001, () -> {
            FlxTimer.wait((1 / 12) * 1, () -> {
                albumTitleShader.setBlackColor(0xFF000000);
                difficultyStars.stars.y = difficultyStars.grp.y;
                
                for(i in 0...difficultyStars.flames.length) {
                    final flame:FlxSprite = difficultyStars.flames.members[i];
                    flame.frameOffset.y = 0;
                }
                albumCover.frameOffset.y = 0;
                albumTitle.frameOffset.y = 0;
            });
        });
    } else {
        albumCover.visible = false;
        albumTitle.visible = false;
        difficultyStars.visible = false;
    }
    lastAlbum = curAlbum;
}

function updateDifficultyDisplay():Void {
    final thing:String = 'menus/freeplay/difficulties/${currentMix ?? "default"}/${currentDifficulty}';
    final xmlPath:String = Paths.xml(thing);
    if(FlxG.assets.exists(xmlPath)) {
        diffDisplay.frames = Paths.getSparrowAtlas(thing);
        diffDisplay.animation.addByPrefix("idle", "idle", 24);
        diffDisplay.animation.play("idle");
    } else
        diffDisplay.loadGraphic(Paths.image(thing));
    
    diffDisplay.offset.set(diffDisplay.width * 0.5, diffDisplay.height * 0.5);
}

function updateDifficultyStars() {
    if(curSelected == 0) {
        difficultyStars.setDifficulty(0);
        return;
    }
    final songMixMeta:SongMetadata = (accessibleSongs[curSelected]?.metadata != null) ? accessibleSongs[curSelected].metadata.get(currentMix) : null;
    difficultyStars.setDifficulty((songMixMeta?.freeplay?.ratings != null) ? (songMixMeta.freeplay.ratings.get(currentDifficulty) ?? 0) : 0);
}

function updateDiscordRPC() {
    final lastSongData:FreeplaySongData = accessibleSongs[curSelected];
    final songMixMeta:SongMetadata = (accessibleSongs[curSelected]?.metadata != null) ? accessibleSongs[curSelected].metadata.get(currentMix) : null;
    DiscordRPC.changePresence("Freeplay Menu", '${(songMixMeta?.song != null) ? songMixMeta.song.title : ((lastSongData?.id != null) ? lastSongData.id : "Unknown")} [${currentDifficulty.toUpperCase()} - ${currentMix.toUpperCase()}]');
    
    vsliceFreeplay_lastSelected = curSelected;
    vsliceFreeplay_lastSongFilter = curSongFilter;
    vsliceFreeplay_lastDifficulty = currentDifficulty;
    vsliceFreeplay_lastMix = currentMix;
}

function updateHighscore() {
    final curSongData:VSliceFreeplaySongData = accessibleSongs[curSelected];
    if(curSongData != null) {
        var key:String = '${curSongData.id}:${currentMix}:${currentDifficulty}:${curSongData.contentPack}';
        if(cachedOpponentMode)
            key += ":opponent";

        final curScoreRecord:ScoreRecord = songScoreRecords.get(key);
        if(curScoreRecord != null) {
            scoreDisplay.tweenNumber(curScoreRecord.score, 0.8);
            percentDisplay.tweenNumber(Math.floor(curScoreRecord.accuracy * 100), 0.8);
        } else {
            scoreDisplay.tweenNumber(0, 0.8);
            percentDisplay.tweenNumber(0, 0.8);
        }
    } else {
        scoreDisplay.tweenNumber(0, 0.8);
        percentDisplay.tweenNumber(0, 0.8);
    }
}

function updateOtherShit() {
    updateHighscore();
    updateDifficultyDisplay();
    
    if(lastDifficulty != currentDifficulty || lastMix != currentMix) {
        diffDisplay.y = 115 - 15;
        FlxTween.completeTweensOf(diffDisplay);
        FlxTween.tween(diffDisplay, {y: 115}, 0.1, {ease: FlxEase.cubeOut});
        
        lastDifficulty = currentDifficulty;
        lastMix = currentMix;
    }
    final songMixMeta:SongMetadata = (accessibleSongs[curSelected]?.metadata != null) ? accessibleSongs[curSelected].metadata.get(currentMix) : null;
    curAlbum = (songMixMeta?.freeplay != null) ? songMixMeta.freeplay.album : "vol1";
    updateAlbumDisplay();
    updateDifficultyStars();

    // length should be the same on capsuleBadges, capsuleSmallNumbers, etc
    // so this should be fine
    for(i in 0...capsuleBadges.length) {
        final songData:FreeplaySongData = accessibleSongs[i];
        final songMixMeta:SongMetadata = (songData?.metadata != null) ? songData.metadata.get(currentMix) : null;

        // update bpm and diff numbers
        final newBPM:Float = (songMixMeta?.song?.timingPoints != null) ? songMixMeta.song.timingPoints[0].bpm : 0;
        final newRating:Int = (songMixMeta?.freeplay?.ratings != null) ? (songMixMeta.freeplay.ratings.get(currentDifficulty) ?? 0) : 0;

        var shiftX:Float = 125;
        var tempShift = 0;

        if(newBPM < 100)
            shiftX -= 11;
        
        final bpmNumbers:Array<TrackingSprite> = capsuleSmallNumbers[i];
        for(i in 0...bpmNumbers.length) {
            bpmNumbers[i].trackingOffset.x = shiftX + (i * 11);
            switch(i) {
                case 0:
                    bpmNumbers[i].exists = newBPM >= 100;
              
                    if(newBPM < 100)
                        bpmNumbers[i].anim.play("0");
                    else
                        bpmNumbers[i].anim.play(Std.string(Math.floor(newBPM / 100) % 10));

                case 1:
                    if(newBPM < 10)
                        bpmNumbers[i].anim.play("0");
                    else {
                        bpmNumbers[i].anim.play(Std.string(Math.floor(newBPM / 10) % 10));
                        if(Math.floor(newBPM / 10) % 10 == 1)
                            tempShift = -4;
                    }
                
                case 2:
                    bpmNumbers[i].anim.play(Std.string(newBPM % 10));
                
                default:
                    trace('why the fuck is this being called');
            }
            bpmNumbers[i].trackingOffset.x += tempShift;
        }
        final firstDigit:Int = (newBPM >= 100) ? 0 : 1;
        if(bpmNumbers.length != 0 && bpmNumbers[firstDigit].anim.name == "1")
            bpmNumbers[firstDigit].trackingOffset.x += 4;
        
        final diffNumbers:Array<TrackingSprite> = capsuleBigNumbers[i];
        final ratingPadded:String = (newRating < 10) ? '0${newRating}' : '${newRating}';
        for(i in 0...diffNumbers.length) {
            switch(i) {
                case 0:
                    if(newRating < 10)
                        diffNumbers[i].anim.play("0");
                    else
                        diffNumbers[i].anim.play(Std.string(Math.floor(newRating / 10)));
                    
                case 1:
                    diffNumbers[i].anim.play(Std.string(newRating % 10));
                
                default:
                    trace('why the fuck is this being called');
            }
        }
        if(diffNumbers.length != 0) {
            if(diffNumbers[0].anim.name == "1") {
                diffNumbers[0].trackingOffset.x = 405;
                diffNumbers[1].trackingOffset.x = 425;
            } else {
                diffNumbers[0].trackingOffset.x = 400;
                diffNumbers[1].trackingOffset.x = 430;
            }
        }
        // update badge
        final rankBadge:FlxSprite = capsuleBadges[i][0];
        final blurredRankBadge:TrackingSprite = rankBadge.extra.get("blurredBadge");

        var key:String = '${songData.id}:${currentMix}:${currentDifficulty}:${songData.contentPack}';
        if(cachedOpponentMode)
            key += ":opponent";
        
        final scoreRecord:ScoreRecord = songScoreRecords.get(key);
        rankBadge.exists = blurredRankBadge.exists = scoreRecord != null && scoreRecord.rank != "unknown";        

        if(rankBadge.exists) {
            rankBadge.anim.play(scoreRecord.rank);
            rankBadge.anim.finish();

            blurredRankBadge.anim.play(scoreRecord.rank);
            blurredRankBadge.anim.finish();
        }
    }
    if(instPreviewTimer != null)
        instPreviewTimer.cancel();
    
    instPreviewTimer = FlxTimer.wait(0.5, () -> {
        final songData:FreeplaySongData = accessibleSongs[curSelected];
        final bgmID:String = '${songData.id}:${currentMix}:${songData.contentPack}';
        if(loadedSongs.get(bgmID) == null) {
            loadedSongs.set(bgmID, {
                id: bgmID,
                sound: null,
                path: null
            });
            final sndPath:String = Paths.sound((curSelected == 0) ? "menus/music/freeplayRandom/music" : 'gameplay/songs/${songData.id}/${currentMix}/music/inst');
            final result:ScriptedThreadResult = CoolUtil.loadSoundASync(sndPath, [bgmID]);
            result.onComplete.add((snd:Sound, args:Array<Dynamic>) -> {
                loadedSongs.set(args[0], {
                    id: bgmID,
                    sound: snd,
                    path: (curSelected == 0) ? "menus/music/freeplayRandom" : null
                });
            });
        }
    });
}

function isSongFavorited(songID:String, contentPack:String) {
    if(vsliceExperience_save.data.favorited == null)
        vsliceExperience_save.data.favorited = {};

    return Reflect.field(vsliceExperience_save.data.favorited, '${songID}:${contentPack}') == true;
}

function favoriteSong(songID:String, contentPack:String) {
    if(vsliceExperience_save.data.favorited == null)
        vsliceExperience_save.data.favorited = {};
    
    Reflect.setField(vsliceExperience_save.data.favorited, '${songID}:${contentPack}', true);
    vsliceExperience_save.flush();

    final favBadge:TrackingSprite = capsuleBadges[curSelected][1];
    for(spr in [favBadge, favBadge.extra.get("blurredBadge")]) {
        spr.exists = true;
        spr.anim.play('fav', true);
    }
    FlxG.sound.play(Paths.sound("menus/freeplay/sfx/fav"));
}

function unfavoriteSong(songID:String, contentPack:String) {
    if(vsliceExperience_save.data.favorited == null)
        vsliceExperience_save.data.favorited = {};

    Reflect.setField(vsliceExperience_save.data.favorited, '${songID}:${contentPack}', false);
    vsliceExperience_save.flush();

    final favBadge:TrackingSprite = capsuleBadges[curSelected][1];
    for(spr in [favBadge, favBadge.extra.get("blurredBadge")]) {
        spr.exists = true;
        spr.anim.play('unfav', true, true);
    }
    FlxG.sound.play(Paths.sound("menus/freeplay/sfx/unfav"));
}

function changeSelection(?by:Int, ?force:Bool) {
    by ??= 0;
    force ??= false;

    if(by == 0 && !force)
        return;

    curSelected = FlxMath.wrap(curSelected + by, 0, grpCapsules.length - 1);
    for(i in 0...grpCapsules.length) {
        final capsule:SongCapsule = grpCapsules.members[i];
        if(i == curSelected)
            capsule.anim.play('selected');
        else
            capsule.anim.play('idle');

        final songName:TrackingSprite = grpSongNames.members[i];
        if(i == curSelected)
            songName.alpha = 1;
        else
            songName.alpha = 0.6;
        
        final badges:Array<TrackingSprite> = capsuleBadges[i];
        for(j in 0...badges.length) {
            final badge:TrackingSprite = badges[j];
            if(i == curSelected) {
                badge.alpha = 1;
                if(badge.extra.exists("blurredBadge"))
                    badge.extra.get("blurredBadge").alpha = 1;
            } else {
                badge.alpha = 0.6;
                if(badge.extra.exists("blurredBadge"))
                    badge.extra.get("blurredBadge").alpha = 0;
            }
        }
    }
    totalTime = 0;

    if(instPreviewTimer != null) {
        instPreviewTimer.cancel();
        instPreviewTimer = null;
    }
    changeDifficulty(0, true);
    updateDiscordRPC();

    if(!force)
        FlxG.sound.play(Paths.sound("menus/sfx/scroll"));
}

function changeFilter(?by:Int, ?force:Bool) {
    by ??= 0;
    force ??= false;

    if(by == 0 && !force)
        return;

    curSongFilter = FlxMath.wrap(curSongFilter + by, 0, songFilters.length - 1);
    for(i in 0...grpCategories.length) {
        final category:FunkinSprite = grpCategories.members[i];

        category.anim.addBySymbol("move", songFilters[FlxMath.wrap(curSongFilter + (i - 2), 0, songFilters.length - 1)] + " move", 24, true);
        category.anim.play("move");
        
        if(i != 2) {
            category.anim.pause();
            category.setPosition(grpCategories.x + (i * 80) + 26, grpCategories.y + -18);
        } else {
            category.anim.resume();
            category.setPosition(grpCategories.x + (i * 80) + 10, grpCategories.y + -28);
        }
        category.updateHitbox();
    }
    regenCapsules(songFilters[curSongFilter]);
    if(accessibleSongs.length <= 1) {
        curSelected = 0;
        changeSelection(0, true);
    }
    var updateSel:Bool = false;
    while(curSelected >= accessibleSongs.length) {
        curSelected--;
        updateSel = true;
    }
    if(updateSel)
        changeSelection(0, true);

    changeDifficulty(0, true);
    changeMix(0, true);
}

function changeDifficulty(?by:Int, ?force:Bool) {
    by ??= 0;
    force ??= false;

    if(by == 0 && !force)
        return;

    final selectedRandom:Bool = curSelected == 0;
    if(selectedRandom)
        curSelected = (accessibleSongs.length > 1) ? 1 : 0; // assume first song ifpossible

    final capsule:SongCapsule = grpCapsules.members[curSelected];
    final songMeta:ChartMetadata = (accessibleSongs[curSelected]?.metadata != null) ? accessibleSongs[curSelected].metadata.get("default") : null;
    
    var currentMixIndex:Int = (songMeta?.song != null) ? songMeta.song.mixes.indexOf(currentMix) : -1;
    currentMix = (songMeta?.song != null) ? songMeta.song.mixes[currentMixIndex] : "default";

    final songMixMeta:ChartMetadata = (accessibleSongs[curSelected]?.metadata != null) ? accessibleSongs[curSelected].metadata.get(currentMix) : null;
    final diffs:Array<String> = (songMixMeta?.song != null) ? songMixMeta.song.difficulties : ["easy", "normal", "hard"];
    
    var currentDifficultyIndex:Int = diffs.indexOf(currentDifficulty);
    currentDifficultyIndex += by;
    currentDifficulty = diffs[currentDifficultyIndex];

    if(selectedRandom)
        curSelected = 0;

    if(currentDifficultyIndex < 0) {
        changeMix(-1);
        final songMixMeta:ChartMetadata = (accessibleSongs[curSelected]?.metadata != null) ? accessibleSongs[curSelected].metadata.get(currentMix) : null;
        final variantDiffs:Array<String> = (songMixMeta?.song != null) ? songMixMeta.song.difficulties : diffs;
        currentDifficulty = variantDiffs[variantDiffs.length - 1];
    }
    else if(currentDifficultyIndex > diffs.length - 1) {
        changeMix(1);
        final songMixMeta:ChartMetadata = (accessibleSongs[curSelected]?.metadata != null) ? accessibleSongs[curSelected].metadata.get(currentMix) : null;
        final variantDiffs:Array<String> = (songMixMeta?.song != null) ? songMixMeta.song.difficulties : diffs;
        currentDifficulty = variantDiffs[0];
    }
    updateOtherShit();
    updateDiscordRPC();
}

function changeMix(?by:Int = 0, ?force:Bool = false):Void {
    if(by == 0 && !force)
        return;

    final capsule:SongCapsule = grpCapsules.members[curSelected + 1];

    final lastSongData:FreeplaySongData = accessibleSongs[curSelected];
    final songMeta:ChartMetadata = (lastSongData?.metadata != null) ? lastSongData.metadata.get("default") : null;
    
    var currentMixIndex:Int = (songMeta?.song != null) ? songMeta.song.mixes.indexOf(currentMix) : -1;
    if(songMeta != null && songMeta.song.mixes.length != 0)
        currentMixIndex = FlxMath.wrap(currentMixIndex + by, 0, songMeta.song.mixes.length - 1);
    else
        currentMixIndex = 0;

    currentMix = (songMeta?.song != null) ? songMeta.song.mixes[currentMixIndex] : "default";
    
    final songMixMeta:ChartMetadata = (accessibleSongs[curSelected]?.metadata != null) ? accessibleSongs[curSelected].metadata.get(currentMix) : null;
    final diffs:Array<String> = (songMixMeta?.song != null) ? songMixMeta.song.difficulties : ["easy", "normal", "hard"];
    
    var currentDifficultyIndex:Int = diffs.indexOf(currentDifficulty);
    currentDifficultyIndex = FlxMath.wrap(currentDifficultyIndex + by, 0, diffs.length - 1);
    currentDifficulty = diffs[currentDifficultyIndex];
    
    if(lastMix != currentMix)
        regenCapsules(songFilters[curSongFilter]);
    
    updateOtherShit();
    for(i in 0...accessibleSongs.length) {
        final songData:FreeplaySongData = accessibleSongs[i];
        if(songData.id == lastSongData.id) {
            curSelected = i;
            break;
        }
    }
    changeSelection(0, true);
    updateDiscordRPC();
}

function switchState(nextState:NextState) {
    persistentUpdate = false;
    if(FlxG.state == super) {
        final shit = Type.createInstance(TransitionableState.defaultTransOut, []);
        openSubState(shit);

        shit.finishCallback = () -> FlxG.switchState(nextState);
        shit.start(1);
    } else
        FlxG.switchState(nextState);
}

function loadIntoGameplay(nextState:NextState) {
    persistentUpdate = false;
    if(FlxG.state == super) {
        final shit = Type.createInstance(TransitionableState.defaultTransOut, []);
        openSubState(shit);

        shit.finishCallback = () -> LoadingState.loadIntoGameplay(nextState);
        shit.start(1);
    } else
        LoadingState.loadIntoGameplay(nextState);
}

function loadIntoCharter():Void {
    final songData:FreeplaySongData = accessibleSongs[curSelected];
    switchState(() -> new ChartEditor({
        song: songData.id,
        difficulty: currentDifficulty,
        mix: currentMix,
        mod: songData.contentPack
    }));
}

function loadIntoSong():Void {
    final songData:FreeplaySongData = accessibleSongs[curSelected];
    PlayState.deathCounter = 0;
    PlayState.lastParams = {
        song: songData.id,
        difficulty: currentDifficulty,
        mix: currentMix,
        mod: songData.contentPack
    };
    loadIntoGameplay(() -> new PlayState(PlayState.lastParams));
}

function callOntoDJ(method:String, ?args:Array<Dynamic>) {
    if(djScript != null)
        djScript.call(method, args);
}

function makeDifficultyStars(x:Float, y:Float):DifficultyStars {
    final flameX:Float = 917;
    final flameY:Float = 103;

    final flameSpreadX = 29;
    final flameSpreadY = 6;

    final flameTimer:Float = 0.25;

    final ret:DifficultyStars = {
        grp: new FlxSpriteGroup(x, y), // containing the next 2 variables

        flames: null,
        stars: null,

        difficulty: 1,
        curDifficulty: 0,

        flameCount: 0,
        timers: [],

        flameX: flameX,
        flameY: flameY,

        flameSpreadX: flameSpreadX,
        flameSpreadY: flameSpreadY,

        positionedFlames: false
    };
    ret.setFlameCount = (value:Int) -> {
        // Stop all existing timers.
		// This fixes a bug where quickly switching difficulties would show flames.
		for(timer in ret.timers.copy()) {
			timer.cancel();
			ret.timers.remove(timer);
		}
		ret.flameCount = value;

		var visibleCount:Int = 0;
		for(i in 0...5) {
			if(ret.flames.members[i] == null)
				continue;

			var flame:FlxSprite = ret.flames.members[i];
			if(i < ret.flameCount) {
				if(!flame.exists) {
					var nextTimer:FlxTimer = new FlxTimer().start(flameTimer * visibleCount, (currentTimer:FlxTimer) -> {
						if(i >= ret.flameCount)
							return;
						
						ret.timers.remove(currentTimer);
						flame.animation.play("flame", true);
						flame.exists = true;
					});
					ret.timers.push(nextTimer);
					visibleCount++;
				}
			}
            else
				flame.exists = false;
		}
    };
    ret.flameCheck = () -> {
        if(ret.difficulty > 10)
            ret.setFlameCount(ret.difficulty - 10);
        else
            ret.setFlameCount(0);
    };
    ret.flames = new FlxSpriteGroup();
    for(i in 0...5) {
        var flame:FlxSprite = new FlxSprite(flameX + (flameSpreadX * i), flameY + (flameSpreadY * i));
        flame.frames = Paths.getSparrowAtlas("menus/freeplay/flame");
        flame.animation.addByPrefix("flame", "fire loop full instance 1", FlxG.random.int(23, 25), false);
        flame.animation.play("flame");
        // flame.makeSolid(50, 50, FlxColor.WHITE);
        flame.exists = false;
        ret.setFlameCount(0);

        // sets the loop... maybe better way to do this lol!
        flame.animation.onFinish.add((_) -> {
            flame.animation.play("flame", true, false, 2);
        });
        ret.flames.add(flame);
    }
    ret.grp.add(ret.flames);

    ret.stars = new FunkinSprite();
    ret.stars.loadAnimateFrames("menus/freeplay/stars");
    ret.stars.anim.addBySymbol("stars", "diff stars", 24, false);
    ret.stars.anim.play("stars");
    ret.grp.add(ret.stars);

    ret.setDifficulty = (value:Int) -> {
        if(value <= 0) {
            ret.difficulty = 0;
			ret.curDifficulty = 15;
		} else if(value <= 15) {
            ret.difficulty = value;
			ret.curDifficulty = ret.difficulty - 1;
		} else {
			ret.difficulty = 15;
			ret.curDifficulty = ret.difficulty - 1;
		}
        if(ret.curDifficulty == 15) {
            ret.stars.anim.play("stars", true, false, 1500);
            ret.stars.anim.pause();
        } else {
            ret.stars.anim.play("stars", true, false, Std.int(ret.curDifficulty * 100));
            ret.stars.anim.curAnim.curFrame = Std.int(ret.curDifficulty * 100);
        }
		ret.flameCheck();
    };
    return ret;
}

function makeDigitDisplay(_x:Float, _y:Float, _path:String, _digitCount:Int, ?_scale:Float, ?_spacing:Float, ?_startingNumber:Int, ?_hideTrailingZeroes:Bool, ?_hasEmptyDigit:Bool) {
    _scale ??= 1.0;
    _spacing ??= 0.0;
    _startingNumber ??= 0;
    _hideTrailingZeroes ??= false;
    _hasEmptyDigit ??= false;

    final ret = {
        ease: FlxEase.linear,
        grp: new FlxSpriteGroup(_x, _y),

        numString: "",

        digitScale: _scale,
        spacing: _spacing,
        digitCount: _digitCount,
        digits: [],
        digitPath: _path,
        hasEmptyDigit: _hasEmptyDigit,

        hideTrailingZeroes: _hideTrailingZeroes,
        totalDistance: 0,
        offsetMap: ["" => 0.0],

        callback: null,
        numberString: ["ZERO", "ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE"]
    };
    ret.tweenValue = FlxTween.tween(ret.grp, {}, 0);
    ret.addDigit = () -> {
        final digit = {
            spr: new FunkinSprite(),
            offsetMap: ["" => 0.0],
            ready: false,
        };
        digit.spr.frames = Paths.getSparrowAtlas(ret.digitPath);
        for (i in 0...ret.numberString.length) {
			digit.spr.animation.addByPrefix("" + i, ret.numberString[i], 24, false);
			digit.offsetMap.set("" + i, 0);
		}
		// Whether the empty digit has a unique sprite or not.
		if(_hasEmptyDigit)
			digit.spr.animation.addByPrefix("-", "DISABLED", 24, false);
		else
			digit.spr.animation.addByPrefix("-", "ZERO", 24, false);
		
		digit.offsetMap.set("-", 0);

		digit.spr.animation.play("0", true);
		digit.spr.animation.onFrameChange.add((name:String, frameNumber:Int, frameIndex:Int) -> {
			digit.setOffset();
		});
		digit.spr.antialiasing = true;

        digit.setOffset = () -> {
            digit.spr.centerOffsets();
            digit.spr.offset.x += digit.offsetMap.get(digit.spr.animation.name) * digit.spr.scale.x;
        };
        ret.digits.push(digit);
        ret.grp.add(digit.spr);
    };
    ret.setDigitOffset = (number:String, offset:Float) -> {
        for (i in 0...ret.digits.length) {
			ret.offsetMap.set(number, offset);
			ret.digits[i].offsetMap.set(number, offset);
			ret.digits[i].setOffset();
		}
    };
    ret.repositionDigits = () -> {
        for (digit in ret.digits) {
			if(digit.ready) {
				continue;
			}
			digit.spr.scale.set(ret.digitScale, ret.digitScale);
			digit.spr.updateHitbox();
			digit.setOffset();
			digit.spr.x = ret.grp.x + ret.totalDistance;
			digit.ready = true;
			ret.totalDistance += digit.spr.width + (ret.spacing * ret.digitScale);
		}
    };
    ret.setNumber = (number:Int, forceAllDigitsToAnimate:Bool, dontExitOnSameNumber:Bool) -> {
        forceAllDigitsToAnimate ??= false;
        dontExitOnSameNumber ??= false;

		var newNumber = Std.string(number);

		if(ret.digitCount >= 0) {
			if(newNumber.length < ret.digitCount) {
				while(newNumber.length < ret.digitCount)
					newNumber = "-" + newNumber;
            
			} else if(newNumber.length > ret.digitCount) {
				newNumber = newNumber.substr(newNumber.length - ret.digitCount);
			}
		} else {
			if(newNumber.length < ret.digits.length) {
				while(newNumber.length < ret.digits.length)
					newNumber = "-" + newNumber;
			} else {
				while(newNumber.length > ret.digits.length)
					ret.addDigit();
				
				for (key => value in offsetMap)
					ret.setDigitOffset(key, value);
				
				ret.repositionDigits();
			}
		}
		if(newNumber == ret.numString && !dontExitOnSameNumber)
			return;
		else
			ret.numString = newNumber;

		if(ret.callback != null)
			ret.callback(ret.numString);

		for (i in 0...ret.numString.length) {
			ret.digits[i].visible = true;
			if(ret.digits[i].spr.animation.name != ret.numString.charAt(i) || forceAllDigitsToAnimate) {
				ret.digits[i].spr.animation.play(ret.numString.charAt(i));
				ret.digits[i].spr.alpha = 1;
			}
			if(ret.hideTrailingZeroes && ret.numString.charAt(i) == "-") {
				ret.digits[i].spr.animation.play(ret.numString.charAt(i));
				ret.digits[i].spr.alpha = 0;
			}
		}
	}
    ret.tweenNumber = (newNumber:Int, tweenTime:Float, force:Bool) -> {
        force ??= false;
		ret.tweenValue.cancel();

		var value = Std.parseFloat(StringTools.replace(ret.numString, "-", "0"));
        if(Math.isNaN(value))
            value = 0.0;

		ret.tweenValue = FlxTween.num(value, newNumber, tweenTime, {ease: ret.ease}, (v) -> {
			ret.setNumber(Std.int(v), force);
		});
	};
    var addDigitCount = (ret.digitCount >= 1) ? ret.digitCount : 1;
    for(i in 0...addDigitCount)
        ret.addDigit();
    
    ret.repositionDigits();
    return ret;
}

function makeColorGradientShader(?_blackColor:FlxColor, ?_whiteColor:FlxColor) {
    _blackColor ??= FlxColor.BLACK;
    _whiteColor ??= FlxColor.WHITE;

    final ret = {
        shader: new CustomShader("color_gradient")
    };
    ret.setBlackColor = (color:FlxColor) -> {
        final realColor:FlxColor = new FlxColor(color); // makes a wrapper usable in hscript
        ret.shader.setFloatArray("blackColor", [realColor.redFloat, realColor.greenFloat, realColor.blueFloat, realColor.alphaFloat]);
    };
    ret.setWhiteColor = (color:FlxColor) -> {
        final realColor:FlxColor = new FlxColor(color); // makes a wrapper usable in hscript
        ret.shader.setFloatArray("whiteColor", [realColor.redFloat, realColor.greenFloat, realColor.blueFloat, realColor.alphaFloat]);
    };
    ret.setBlackColor(_blackColor);
    ret.setWhiteColor(_whiteColor);
    return ret;
}

function onAccept() {
    if(curSelected == 0) {
        // 1st entry is always "Random", so select a random song!
        curSelected = FlxG.random.int(1, grpCapsules.length - 1);
        changeSelection(0, true);
    }
    if(grpCapsules.length < 2) {
        final capsule:SongCapsule = grpCapsules.members[curSelected];
        final songName:TrackingSprite = grpSongNames.members[curSelected];

        for(spr in [capsule, songName])
            spr.updateHitbox();
        
        FlxTween.cancelTweensOf(capsule);
        FlxTween.shake(capsule, 0.01, 0.16, FlxAxes.XY, {
            onUpdate: (t:FlxTween) -> {
                songName.offset.set(capsule.offset.x - t.initialOffset.x, capsule.offset.y - t.initialOffset.y);
            },
            onComplete: (_) -> songName.updateHitbox()
        });
        
        FlxG.sound.play(Paths.sound("menus/sfx/cancel"));
        return;
    }
    accepted = true;
    callOntoDJ("onAccept");
    callOntoDJ("onConfirm");
    callOntoDJ("onConfirmSong");
    callOntoDJ("onSongConfirm");

    FlxTimer.wait(1.5, () -> {
        if(FlxG.state.subState != null) {
            FlxG.state.persistentDraw = true;
            FlxG.state.subState = null;
            FlxG.state.add(super);
            Reflect.setProperty(super, "_parentState", null);
        }
        FlxTimer.wait(0.001, () -> {
            if(FlxG.keys.pressed.SHIFT)
                loadIntoCharter();
            else
                loadIntoSong();

            if(FlxG.sound.music != null)
                FlxG.sound.music.fadeOut(0.16, 0);
        });
    });
    FlxTimer.loop(1 / 24, () -> {
        flickerState = (flickerState + 1) % 2;

        final songName:TrackingSprite = grpSongNames.members[curSelected];
        songName.loadGraphic(songName.extra.get("bitmaps")[flickerState]);
    }, 32);

    final icon:TrackingSprite = capsuleIcons[curSelected];
    if(icon != null)
        icon.anim.play("confirm");

    FlxG.sound.play(Paths.sound("menus/sfx/select"));
}

function onExit() {
    bgmThreadActive = false;
    if(parent != null)
        parent.persistentDraw = true;
    
    callOntoDJ("onExit");
    callOntoDJ("onCancel");

    pinkBG.revive();
    FlxTween.tween(capsuleData, {offsetX: FlxG.width}, 0.5, {ease: FlxEase.cubeIn});
    
    // left side
    FlxTween.tween(dj, {x: -dj.width}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(pinkBG, {x: -pinkBG.width}, 0.5, {ease: FlxEase.cubeIn});

    FlxTween.tween(diffDisplay, {x: diffDisplay.x - pinkBG.width}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(diffLeftSelector, {x: diffLeftSelector.x - pinkBG.width}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(diffRightSelector, {x: diffRightSelector.x - pinkBG.width}, 0.5, {ease: FlxEase.cubeIn});
    
    // right side
    FlxTween.tween(dadCover, {x: FlxG.width}, 0.5, {ease: FlxEase.cubeIn});

    FlxTween.tween(albumCover, {x: albumCover.x + dadCover.width}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(albumTitle, {x: albumTitle.x + dadCover.width}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(difficultyStars.grp, {x: difficultyStars.grp.x + dadCover.width}, 0.5, {ease: FlxEase.cubeIn});

    FlxTween.tween(highScoreText, {x: highScoreText.x + dadCover.width}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(scoreDisplay.grp, {x: scoreDisplay.grp.x + dadCover.width}, 0.5, {ease: FlxEase.cubeIn});

    FlxTween.tween(clearBox, {x: clearBox.x + dadCover.width}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(percentDisplay.grp, {x: percentDisplay.grp.x + dadCover.width}, 0.5, {ease: FlxEase.cubeIn});

    // top
    FlxTween.tween(header, {y: -(header.height * 2)}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(headerFreeplayText, {y: headerFreeplayText.y - (header.height * 2)}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(headerOSTText, {y: headerOSTText.y - (header.height * 2)}, 0.5, {ease: FlxEase.cubeIn});

    FlxTween.tween(grpCategoryArrows, {y: grpCategoryArrows.y - (header.height * 2)}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(grpCategorySeparators, {y: grpCategorySeparators.y - (header.height * 2)}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(grpCategories, {y: grpCategories.y - (header.height * 2)}, 0.5, {ease: FlxEase.cubeIn});

    if(FlxG.sound.music != null)
        FlxG.sound.music.fadeOut(0.5, 0.0);

    FlxTimer.wait(0.55, () -> {
        if(FlxG.state == super) {
            FlxG.game._state = members[0];
            FlxG.game._state.active = true;
            FlxG.game._state._cameras = null;

            remove(members[0], true);
            super.destroy();
        } else {
            FlxG.state.updateDiscordRPC();
            close();
        }
        CoolUtil.playMenuMusic();
    });
    FlxG.sound.play(Paths.sound("menus/sfx/cancel"));
}

function onCreate() {
    persistentUpdate = true;

    for(contentPack in Paths.getEnabledContentPacks()) {
        final contentMetadata:ContentMetadata = Paths.contentMetadata.get(contentPack);
        if(contentMetadata == null)
            continue; // ifno metadata was found for this content pack, then don't bother
        
        for(category in contentMetadata.freeplayCategories) {
            categories.push({
                id: '${contentPack}:${category.id}',
                name: category.name
            });
            categoryMap.set('${contentPack}:${category.id}', category);
        }
        for(level in contentMetadata.levels) {
            if(!level.showInFreeplay)
                continue;

            final categoryID:String = '${contentPack}:${level.freeplayCategory}';
            if(!songListMap.exists(categoryID))
                songListMap.set(categoryID, []);

            final validSongs:Array<String> = [];
            for(song in level.songs) {
                if(level.hiddenSongs.freeplay.contains(song))
                    continue;

                if(!FlxG.assets.exists(Paths.json('gameplay/songs/${song}/default/metadata', contentPack)))
                    continue;

                validSongs.push(song);
            }
            addSongsToCategory(level.freeplayCategory, validSongs, contentPack);
        }
    }
    pinkBG = new FunkinSprite().loadGraphic(Paths.image("menus/freeplay/pink_bg"));
    pinkBG.x = -pinkBG.width;
    pinkBG.screenCenter(FlxAxes.Y);
    add(pinkBG);

    final djScriptPath:String = Paths.script('menus/freeplay/dj/${curCharacter}/script');
    if(FlxG.assets.exists(djScriptPath)) {
        djScript = FunkinScript.fromFile(djScriptPath);
        djScript.set("menu", super);
        djScript.set("djName", curCharacter);
        djScript.set("curCharacter", curCharacter);
        djScript.set("curMenuDJ", curCharacter);
        djScript.set("curDJ", curCharacter);
        djScript.execute();

        djScript.call("new");
        djScript.call("onLoad");

        dj = djScript.call("initDJ");
        djScript.call("playIntro");

        super.subStateScripts.add(djScript);
    }
    dadCover = new FunkinSprite().loadGraphic(Paths.image('menus/freeplay/covers/dad${(curCharacter != "bf") ? '-${curCharacter}' : ""}'));
    dadCover.x = FlxG.width;
    dadCover.screenCenter(FlxAxes.Y);
    dadCover.color = FlxColor.BLACK;
    add(dadCover);

    albumCover = new FunkinSprite(FlxG.width - 330, 0);
    albumCover.loadGraphic(Paths.image("menus/freeplay/album/vol1/album"));
    albumCover.screenCenter(FlxAxes.Y);
    albumCover.angle = 10;
    albumCover.y += 55;
    albumCover.kill();
    add(albumCover);

    albumTitle = new FunkinSprite(albumCover.x - 25, albumCover.y + 216);
    albumTitle.loadGraphic(Paths.image("menus/freeplay/album/vol1/title"));
    albumTitle.kill();
    add(albumTitle);

    albumTitleShader = makeColorGradientShader();
    albumTitle.shader = albumTitleShader.shader;

    difficultyStars = makeDifficultyStars(955, 220);
    add(difficultyStars.grp);

    grpCapsules = new FlxTypedGroup();
    add(grpCapsules);

    grpSongNames = new FlxTypedGroup();
    add(grpSongNames);

    grpSongIcons = new FlxTypedGroup();
    add(grpSongIcons);

    grpCapsuleExtras = new FlxTypedGroup();
    add(grpCapsuleExtras);

    diffDisplay = new FunkinSprite(197, 115);
    diffDisplay.loadGraphic(Paths.image("menus/freeplay/difficulties/default/hard"));
    diffDisplay.kill();
    add(diffDisplay);
    
    diffLeftSelector = new FunkinSprite(20, 70);
    diffLeftSelector.frames = Paths.getSparrowAtlas('menus/freeplay/skins/${curCharacter}/selector');
    diffLeftSelector.animation.addByPrefix("idle", "arrow pointer loop", 24);
    diffLeftSelector.animation.play("idle");
    diffLeftSelector.kill();
    add(diffLeftSelector);
    
    diffRightSelector = new FunkinSprite(325, 70);
    diffRightSelector.frames = Paths.getSparrowAtlas('menus/freeplay/skins/${curCharacter}/selector');
    diffRightSelector.animation.addByPrefix("idle", "arrow pointer loop", 24);
    diffRightSelector.animation.play("idle");
    diffRightSelector.flipX = true;
    diffRightSelector.kill();
    add(diffRightSelector);

    grpCategoryArrows = new FlxTypedSpriteGroup();
    grpCategoryArrows.setPosition(380, 90);
    grpCategoryArrows.kill();
    add(grpCategoryArrows);

    grpCategorySeparators = new FlxTypedSpriteGroup();
    grpCategorySeparators.setPosition(grpCategoryArrows.x, grpCategoryArrows.y);
    grpCategorySeparators.kill();
    add(grpCategorySeparators);
    
    grpCategories = new FlxTypedSpriteGroup();
    grpCategories.setPosition(grpCategoryArrows.x, grpCategoryArrows.y);
    grpCategories.kill();
    add(grpCategories);

    for(i in 0...4) {
        final sep:FunkinSprite = new FunkinSprite().loadGraphic(Paths.image("menus/freeplay/separator"));
        sep.setPosition((i * 80) + 80, 4);
        grpCategorySeparators.add(sep);
    }
    for(i in 0...5) {
        final category:FunkinSprite = new FunkinSprite();
        category.loadAnimateFrames("menus/freeplay/categories");
        category.setPosition((i * 80) + 70, 35);

        category.anim.addBySymbol("move", songFilters[FlxMath.wrap(curSongFilter + (i - 2), 0, songFilters.length - 1)] + " move", 24, false);
        category.anim.play("move");

        var darkness:Float = Math.abs(i - 2) / 6;
        category.color = new FlxColor(0xFFFFFFFF).getDarkened(darkness);
        
        if(i != 2) {
            category.scale.set(0.8, 0.8);
            category.updateHitbox();
            category.anim.pause();
        }
        grpCategories.add(category);
    }
    categoryLeftArrow = new FunkinSprite().loadGraphic(Paths.image("menus/freeplay/mini_arrow"));
    categoryLeftArrow.scale.set(0.7, 0.7);
    categoryLeftArrow.updateHitbox();
    categoryLeftArrow.flipX = true;
    grpCategoryArrows.add(categoryLeftArrow);

    categoryRightArrow = new FunkinSprite().loadGraphic(Paths.image("menus/freeplay/mini_arrow"));
    categoryRightArrow.x = 400;
    categoryRightArrow.scale.set(0.7, 0.7);
    categoryRightArrow.updateHitbox();
    grpCategoryArrows.add(categoryRightArrow);

    header = new FunkinSprite().makeSolid(FlxG.width, 65, 0xFF000000);
    header.y -= header.height;
    add(header);
    
    headerFreeplayText = new FlxText(10, 6, 0, "FREEPLAY");
    headerFreeplayText.setFormat(Paths.font("fonts/vcr"), 48);
    headerFreeplayText.y -= header.height;
    headerFreeplayText.kill();
    add(headerFreeplayText);
    
    headerOSTText = new FlxText(FlxG.width - 10, 6, 0, "OFFICIAL OST");
    headerOSTText.setFormat(Paths.font("fonts/vcr"), 48);
    headerOSTText.x -= headerOSTText.width;
    headerOSTText.y -= header.height;
    headerOSTText.kill();
    add(headerOSTText);

    clearBox = new FunkinSprite(FlxG.width - 12, header.height);
    clearBox.loadGraphic(Paths.image("menus/freeplay/clear_box"));
    clearBox.x -= clearBox.width;
    clearBox.kill();
    add(clearBox);

    highScoreText = new FunkinSprite(FlxG.width - 132, header.height + 5);
    highScoreText.frames = Paths.getSparrowAtlas("menus/freeplay/highscore");
    highScoreText.animation.addByPrefix("idle", "highscore small alt instance 1", 24);
    highScoreText.animation.play("idle");
    highScoreText.x -= highScoreText.width;
    highScoreText.kill();
    add(highScoreText);

    scoreDisplay = makeDigitDisplay(FlxG.width - 362, 120, "menus/freeplay/skins/" + curCharacter + "/digital_numbers", 7, 0.4, -25);
    scoreDisplay.setDigitOffset("1", 20);
    scoreDisplay.ease = FlxEase.cubeOut;
    scoreDisplay.grp.kill();
    add(scoreDisplay.grp);

    percentDisplay = makeDigitDisplay(clearBox.x - 12, 87, "menus/freeplay/clear_text", 3, 1, 3, 0, true);
    percentDisplay.setDigitOffset("1", -8);
    percentDisplay.ease = FlxEase.quadOut;
    percentDisplay.grp.kill();
    add(percentDisplay.grp);

    curSelected = vsliceFreeplay_lastSelected;
    curSongFilter = vsliceFreeplay_lastSongFilter;
    currentDifficulty = vsliceFreeplay_lastDifficulty;
    currentMix = vsliceFreeplay_lastMix;

    changeFilter(0, true);
    difficultyStars.grp.visible = false;

    // final refImg:FlxSprite = new FlxSprite().loadGraphic(Paths.image('${ext}/reference'));
    // refImg.alpha = 0.25;
    // refImg.screenCenter();
    // add(refImg);

    camera = new FlxCamera();
    camera.bgColor = 0;
    FlxG.cameras.add(camera, false);

    FlxTween.tween(pinkBG, {x: 0}, 0.5, {ease: FlxEase.cubeOut});
    FlxTween.tween(dadCover, {x: FlxG.width - dadCover.width}, 0.5, {ease: FlxEase.cubeOut});

    for(obj in [header, headerFreeplayText, headerOSTText])
        FlxTween.tween(obj, {y: obj.y + header.height}, 0.5, {ease: FlxEase.cubeOut});

    FlxTimer.wait(0.5, () -> {
        busy = false;
        optimizeCapsuleUpdating = true; // non-functional, need to make it functional later!

        if(parent != null)
            parent.persistentDraw = false;

        pinkBG.kill();
        dadCover.color = FlxColor.WHITE;

        headerFreeplayText.revive();
        headerOSTText.revive();

        clearBox.revive();
        highScoreText.revive();

        scoreDisplay.grp.revive();
        percentDisplay.grp.revive();
        
        diffDisplay.x = -diffDisplay.width;
        FlxTween.tween(diffDisplay, {x: 197}, 0.5, {ease: FlxEase.cubeOut});
        
        diffDisplay.revive();
        diffLeftSelector.revive();
        diffRightSelector.revive();

        grpCategoryArrows.revive();
        grpCategorySeparators.revive();
        grpCategories.revive();

        albumCover.revive();
        albumCover.x = FlxG.width - 50;
        albumCover.angle = 15;

        // this is messy and stupid and not fully accurate
        // but i don't care it's good enough
        new FlxTimer().start((1 / 12) * 1, (_) -> {
            albumCover.x = FlxG.width - 350;
            albumCover.angle = 5;
        });
        new FlxTimer().start((1 / 12) * 2, (_) -> {
            albumCover.x = FlxG.width - 330;
            albumCover.angle = 10;

            difficultyStars.grp.visible = curSelected != 0;
            updateDifficultyStars();
        });
        new FlxTimer().start((1 / 12) * 4, (_) -> {
            albumTitle.revive();
            albumTitle.scale.set(1.1, 0.9);
        });
        new FlxTimer().start((1 / 12) * 5, (_) -> {
            albumTitle.scale.set(1, 1);
        });
        dadCover.colorTransform.redMultiplier = 0;
        dadCover.colorTransform.greenMultiplier = 0;
        dadCover.colorTransform.blueMultiplier = 0;

        FlxTween.tween(dadCover.colorTransform, {redMultiplier: 1, greenMultiplier: 1, blueMultiplier: 1}, 0.25, {ease: FlxEase.cubeOut});
        callOntoDJ("showBackingCard");
    });
}

function onCreatePost() {
    if(FlxG.state == super) {
        final shit = Type.createInstance(TransitionableState.defaultTransIn, []);
        
        var state:FlxState = super;
        while(state.subState != null)
            state = state.subState;
        
        state.openSubState(shit);

        shit.finishCallback = shit.close;
        shit.start(0);
    }
}

function onUpdatePre(dt:Float) {
    if(!goMyFreeplay) {
        goMyFreeplay = true;
        return;
    }
    if(FlxG.keys.justPressed.END) {
        if(parent != null)
            parent.persistentDraw = true;

        close();
    }
    if(!accepted && !busy) {
        final wheel:Float = -FlxG.mouse.wheel;
        if(controls.justPressed.check(Control.UI_UP) || wheel < 0)
            changeSelection(-1);
    
        if(controls.justPressed.check(Control.UI_DOWN) || wheel > 0)
            changeSelection(1);

        if(controls.justPressed.check(Control.UI_LEFT))
            changeDifficulty(-1);

        if(controls.justPressed.check(Control.UI_RIGHT))
            changeDifficulty(1);

        if(FlxG.keys.justPressed.Q)
            changeFilter(-1);

        if(FlxG.keys.justPressed.E)
            changeFilter(1);
    
        if(controls.justPressed.check(Control.BACK)) {
            accepted = true;
            if(FlxG.game._state == super) {
                final constructor = () -> new MainMenuState();
                
                final menu:MainMenuState = constructor();
                Reflect.setProperty(menu, "_constructor", constructor); // constructor must be set otherwise FlxG.resetState won't work
                menu.create();
                menu.createPost();

                menu.active = false;
                menu.cameras = [FlxG.camera];
                insert(0, menu);
            }
            onExit();
        }
        if(controls.justPressed.check(Control.ACCEPT))
            onAccept();

        if(controls.justPressed.check(Control.RESET)) {
            final songData:VSliceFreeplaySongData = accessibleSongs[curSelected];

            final meta:SongMetadata = accessibleSongs[curSelected].metadata.get(currentMix);
            persistentUpdate = false;

            final subState:ResetScoreSubState = new ResetScoreSubState(meta.song.title);
            subState.onAccept.add(() -> {
                final recordID:String = Highscore.getScoreRecordID(songData.id, currentDifficulty, currentMix, songData.contentPack, cachedOpponentMode);
                Highscore.resetScoreRecord(recordID);

                final badge:TrackingSprite = capsuleBadges[curSelected][0];
                for(b in [badge, badge.extra.get("blurredBadge")])
                    b.exists = false;

                var key:String = '${songData.id}:${currentMix}:${currentDifficulty}:${songData.contentPack}';
                if(cachedOpponentMode)
                    key += ":opponent";
                
                songScoreRecords.set(key, Highscore.getScoreRecord(recordID));
                updateHighscore();
            });
            openSubState(subState);
        }
        final pressedCtrl:Bool = #if (mac || macos) FlxG.keys.justPressed.WINDOWS #else FlxG.keys.justPressed.CONTROL #end;
        if(pressedCtrl) {
            persistentUpdate = false;
            openSubState(new GameplayModifiersMenu());
        }
        // TODO: custom keybind?
        if(FlxG.keys.justPressed.F) {
            busy = true;

            final songData:VSliceFreeplaySongData = accessibleSongs[curSelected];
            if(isSongFavorited(songData.id, songData.contentPack))
                unfavoriteSong(songData.id, songData.contentPack);
            else
                favoriteSong(songData.id, songData.contentPack);
            
            final capsule:SongCapsule = grpCapsules.members[curSelected];
            capsule.extra.set("doLerp", false);
            FlxTween.tween(capsule, {y: capsule.y - 5}, 0.1, {ease: FlxEase.expoOut});
            FlxTween.tween(capsule, {y: capsule.y + 5}, 0.1, {ease: FlxEase.expoIn, startDelay: 0.1, onComplete: () -> {
                capsule.extra.set("doLerp", true);
                busy = false;
            }});
        }
    }
    for(i in 0...grpCapsules.length) {
        final capsule:SongCapsule = grpCapsules.members[i];
        final songName:TrackingSprite = grpSongNames.members[i];
        
        if(capsule.extra.get("doLerp")) {
            final index:Int = capsule.ID - curSelected;
    
            final lerpAmountX:Float = FlxMath.getElapsedLerp(0.3, FlxG.elapsed);
            final lerpAmountY:Float = FlxMath.getElapsedLerp(0.4, FlxG.elapsed);
    
            capsule.setPosition(
                FlxMath.lerp(capsule.x - capsuleData.offsetX, 335 + Math.sin(index + 1) * 60 - (index > 3 ? 50 : 0), lerpAmountX),
                FlxMath.lerp(capsule.y, 250 + (index * 115) - (index < -1 ? 100 : 0), lerpAmountY)
            );
            capsule.x += capsuleData.offsetX;
        }
        var visibleBadges:Int = 0;
        for(b in capsuleBadges[songName.ID]) {
            if(b.exists)
                visibleBadges++;
        }
        final baseTextWidth:Float = (visibleBadges > 1) ? 300 : 305;
        final textWidth:Float = (visibleBadges > 0) ? baseTextWidth - (visibleBadges * 40) : baseTextWidth;
        if(curSelected == songName.ID && !accepted) {
            songName.trackingOffset.x = 88 - ((curSelected == songName.ID && songName.width > textWidth) ? (Math.sin(totalTime * 0.9) * (songName.width - textWidth) * 0.5) + ((songName.width - textWidth) * 0.5) : 0);
            songName.clipRect.set(-(songName.trackingOffset.x - 88), 0, textWidth, songName.frameHeight);
            
            if(songName.width <= textWidth)
                totalTime = 0;
        } else {
            songName.trackingOffset.x = 88;
            songName.clipRect.set(0, 0, textWidth, songName.frameHeight);
        }
    }
    for(arr in capsuleBadges) {
        var x:Int = 0;
        for(badge in arr) {
            if(!badge.exists)
                continue;

            badge.trackingOffset.x = 356 - (x++ * 40);
            badge.extra.get("blurredBadge").trackingOffset.x = badge.trackingOffset.x;
        }
    }
    totalTime += dt;

    final songData:VSliceFreeplaySongData = accessibleSongs[curSelected];
    final meta:SongMetadata = (songData?.metadata != null) ? songData.metadata.get(currentMix) : null;
    
    final opponentMode:Bool = Options.gameplayModifiers.get("opponentMode") == true && ((meta?.game != null) ? meta.game.allowOpponentMode : true);
    if(cachedOpponentMode != opponentMode) {
        cachedOpponentMode = opponentMode;
        
        for(i => arr in capsuleBadges) {
            final badge:TrackingSprite = arr[0];
            final songData:VSliceFreeplaySongData = accessibleSongs[i];
            
            var key:String = '${songData.id}:${currentMix}:${currentDifficulty}:${songData.contentPack}';
            if(cachedOpponentMode)
                key += ":opponent";

            final rank:String = songScoreRecords.get(key)?.rank ?? "unknown";
            for(b in [badge, badge.extra.get("blurredBadge")]) {
                b.exists = rank != "unknown";
                b.anim.play(rank);
            }
        }
        updateHighscore();
    }
    final songData:FreeplaySongData = accessibleSongs[curSelected];
    final bgmID:String = '${songData.id}:${currentMix}:${songData.contentPack}';
    
    final bgmData:BGMData = loadedSongs.get(bgmID);
    if(currentBGM != bgmID && bgmData != null && bgmData.id != null && bgmData.sound != null) {
        currentBGM = bgmID;

        if(bgmData.path != null)
            CoolUtil.playMusic(bgmData.path, 0, true, bgmData.sound); // random button
        else {
            // song capsule
            final songData:FreeplaySongData = accessibleSongs[curSelected];
            FlxG.sound.playMusic(bgmData.sound, 0, true);
            
            final songMeta:ChartMetadata = (songData?.metadata != null) ? songData.metadata.get(currentMix) : null;
            Conductor.instance.music = FlxG.sound.music;
            Conductor.instance.reset((songMeta?.song?.timingPoints != null) ? songMeta.song.timingPoints[0].bpm : 100);

            if((songMeta?.song?.timingPoints != null))
                Conductor.instance.setupTimingPoints(songMeta.song.timingPoints);
        }
        FlxG.sound.music.fadeIn(2, 0.0, 1.0);
    }
}

function onUpdatePost(dt:Float) {
    if(difficultyStars.curDifficulty < 15 && difficultyStars.stars.anim.curAnim.curFrame >= (difficultyStars.curDifficulty + 1) * 100)
		difficultyStars.stars.anim.play("stars", true, false, difficultyStars.curDifficulty * 100);

    if(!difficultyStars.positionedFlames) {
        for(i in 0...5) {
            difficultyStars.flames.members[i].x = difficultyStars.flameX + (difficultyStars.flameSpreadX * i);
            difficultyStars.flames.members[i].y = difficultyStars.flameY + (difficultyStars.flameSpreadY * i);
        }
        difficultyStars.positionedFlames = true;
    }
}

function onDestroy() {
    for(bgmData in loadedSongs) {
        if(bgmData?.sound != null)
            bgmData.sound.close();
    }
    loadedSongs.clear();

    MemoryUtil.clearAll();
    FlxG.cameras.remove(camera);
}