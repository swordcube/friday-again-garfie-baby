import openfl.geom.Point;
import openfl.geom.Matrix;

import openfl.display.BitmapData;
import openfl.filters.BlurFilter;

import flixel.graphics.FlxGraphic;
import animate.internal.FilterRenderer;

import funkin.scripting.FunkinScript;

import funkin.states.TransitionableState;
import funkin.states.editors.ChartEditor;
import funkin.states.menus.FreeplayState.FreeplaySongData;

final ext:String = "menus/freeplay/";

final songNameSelectColor:FlxColor = 0xFFFFFFFF;
final songNameDeselectColor:FlxColor = 0xFF969A9D;
final songNameSelectBorderColor:FlxColor = 0xFF6B9FBA;
final songNameDeselectBorderColor:FlxColor = 0xFF3E508C;

var parent:MainMenuState;

// makin several groups for each part of
// the song capsules, for better batching
var capsuleData = {
    offsetX: 0.0
};
var grpCapsules:FlxTypedGroup<TrackingSprite>;
var grpSongNames:FlxTypedGroup<TrackingSprite>;

var grpSongIcons:FlxTypedGroup<TrackingSprite>;
var grpCapsuleExtras:FlxTypedGroup<TrackingSprite>;

var capsuleBadges:Array<Array<TrackingSprite>> = [];

// groups for category stuff!
var grpCategoryArrows:FlxTypedSpriteGroup<FunkinSprite>;
var grpCategorySeparators:FlxTypedSpriteGroup<FunkinSprite>;
var grpCategories:FlxTypedSpriteGroup<FunkinSprite>;

var diffDisplay:FunkinSprite;
var diffLeftSelector:FunkinSprite;
var diffRightSelector:FunkinSprite;

var categoryLeftArrow:FunkinSprite;
var categoryRightArrow:FunkinSprite;

// taken straight from garfie baby source code
var categories:Array<FreeplayCategory> = [];
var categoryMap:Map<String, FreeplayCategory> = ["" => null];

var songs:Array<VSliceFreeplaySongData> = [];
var songListMap:Map<String, Array<VSliceFreeplaySongData>> = ["" => null];

var curCharacter:String;
var songFilters:Array<String> = [
    "#", // only songs that contain numbers in their title?? i think??
    "fav", // favorited songs
    "ALL", // all songs
    "AB", // only songs that contain A or B in their title
    "CD", // only songs that contain C or D in their title
    "EH", // only songs that contain E or H in their title
    "IL", // only songs that contain I or L in their title
    "MN", // only songs that contain M or N in their title
    "OR", // only songs that contain O or R in their title
    "S", // only songs that contain S in their title
    "T", // only songs that contain T in their title
    "UZ", // only songs that contain U or Z in their title
];
var accessibleSongs:Array<VSliceFreeplaySongData> = [];

var pinkBG:FlxSprite;
var dadCover:FlxSprite;

var albumCover:FunkinSprite;
var albumTitle:FunkinSprite;
var difficultyStars:DifficultyStars;

var curSelected:Int = 1;
var curSongFilter:Int = 2;

var currentDifficulty:String = "normal";
var currentMix:String = "default";

var lastDifficulty:String = "normal";
var lastMix:String = "default";

var currentAlbum:String = "vol1";
var lastAlbum:String = "vol1";

var accepted:Bool = false;
var goMyFreeplay:Bool = false;

var header:FunkinSprite;
var headerFreeplayText:FlxText;
var headerOSTText:FlxText;

var dj:FunkinSprite;
var djScript:FunkinScript;

var totalTime:Float = 0;
var playingIntro:Bool = true;

function new(_parent:MainMenuState, ?menuSkin:String) {
    parent = _parent;
    curCharacter = menuSkin ?? "bf";
}

function addSongsToCategory(categoryID:String, ?songIDs:Array<String>, ?contentPack:String, ?priority:Int):Void {
    priority ??= 0;

    if(contentPack == null)
        contentPack = Paths.forceContentPack;

    if(songIDs == null || songIDs.length == 0)
        return;

    var songList:Array<FreeplaySongData> = songListMap.get('${contentPack}:${categoryID}');
    if(songList == null) {
        songList = [];
        songListMap.set('${contentPack}:${categoryID}', songList);
    }
    for(song in songIDs) {
        final defaultMetadata:SongMetadata = SongMetadata.load(song, null, contentPack);
        final metadataMap:Map<String, SongMetadata> = ["default" => defaultMetadata];
        
        for(mix in defaultMetadata.song.mixes)
            metadataMap.set(mix, SongMetadata.load(song, mix, contentPack));

        final difficultyMap:Map<String, Array<String>> = ["default" => defaultMetadata.song.difficulties];
        for(metadata in metadataMap) {
            for(mix in metadata.song.mixes)
                difficultyMap.set(mix, metadataMap.get(mix).song.difficulties);
        }
        final songData:VSliceFreeplaySongData = {
            metadata: metadataMap,
            id: song,
            difficulties: difficultyMap,
            contentPack: contentPack
        };
        songs.insert(songs.length - priority, songData);
        songList.insert(songList.length - priority, songData);
    }
}

function regenCapsules(filter:String) {
    var songsToFilter:Array<FreeplaySongData> = songs.filter((song:FreeplaySongData) -> {
        return song.metadata.exists(currentMix);
    });
    var filteredSongs:Array<FreeplaySongData> = null;
    switch(filter) {
        case "#":
            final nums:String = "0123456789";
            filteredSongs = songsToFilter.filter((data:FreeplaySongData) -> {
                final meta:SongMetadata = data.metadata.get("default");
                for(i in 0...nums.length) {
                    if(meta != null && StringTools.contains(meta.song.title, nums.charAt(i)))
                        return true;
                }
                return false;
            });

        case "fav":
            filteredSongs = []; // TODO: favorite songs
        
        case "ALL":
            filteredSongs = songsToFilter;

        default:
            if(filter.length == 1) {
                // handle "S" and "T" categories
                filteredSongs = songsToFilter.filter((data:FreeplaySongData) -> {
                    final meta:SongMetadata = data.metadata.get("default");
                    return meta != null && StringTools.contains(meta.song.title, filter);
                });
            } else {
                // handle the two-lettered categories
                filteredSongs = songsToFilter.filter((data:FreeplaySongData) -> {
                    final meta:SongMetadata = data.metadata.get("default");
                    return meta != null && (StringTools.contains(meta.song.title, filter.charAt(0)) || StringTools.contains(meta.song.title, filter.charAt(1)));
                });
            }
    }
    filteredSongs.insert(0, new FreeplaySongData(null, "CUSTOM://random", null));
    accessibleSongs = filteredSongs;

    for(grp in [grpCapsules, grpSongNames, grpSongIcons, grpCapsuleExtras]) {
        while(grp.length > 0) {
            final memb = grp.members[0];
            grp.remove(memb, true);
            memb.destroy();
        }
    }
    final blur:BlurFilter = new BlurFilter();
    capsuleBadges = [];
    
    for(i in 0...filteredSongs.length) {
        // get song metadata
        final songData:FreeplaySongData = filteredSongs[i];
        final songMeta:SongMetadata = (songData.metadata != null) ? songData.metadata.get(currentMix) : null;

        var displayedName:String = null;
        switch(songData.id) {
            case "CUSTOM://random":
                displayedName = "Random";

            default:
                displayedName = songMeta.song.title;
        }

        // make capsule base
        final capsule:FunkinSprite = new FunkinSprite().loadSparrowFrames('${ext}skins/${curCharacter}/capsule');
        capsule.anim.addByPrefix('idle', 'mp3 capsule w backing NOT SELECTED0', 24, true);
        capsule.anim.addByPrefix('selected', 'mp3 capsule w backing0', 24, true);
        capsule.anim.setOffset('selected', 4, 0);
        capsule.anim.play('idle');
        capsule.setPosition(335 + Math.sin((i - curSelected) + 1) * 60 + FlxG.width, -200 + ((i - curSelected) * 115));
        capsule.setScale(0.8, FlxAxes.XY);
        Reflect.setProperty(capsule, "ID", i); // rulescript.
        grpCapsules.add(capsule);

        // make capsule text

        // WARNING: this is kinda of a hack, i'm making an FlxText
        // to generate the song name graphic, then using that graphic
        // on a TrackingSprite. kinda stupid i know
        final textGraphic:FlxText = new FlxText(0, 0, 0, displayedName);
        textGraphic.setFormat(Paths.font("fonts/5by7"), 32, songNameSelectColor);
        textGraphic.color = 0xFF00CCFF;
        textGraphic.regenGraphic();
        
        // generate the blurred part of the text
        final textGlowBitmap:BitmapData = new BitmapData(textGraphic.pixels.width + 12, textGraphic.pixels.height + 12, true, FlxColor.RED);
        final bmd1:BitmapData = new BitmapData(textGlowBitmap.width, textGlowBitmap.height, true, FlxColor.RED);
        FilterRenderer.__applyFilter(textGlowBitmap, bmd1, null, textGraphic.pixels, [blur], new Point(6, 6));
        
        // make the text white and regen graphic
        textGraphic.color = FlxColor.WHITE;
        textGraphic.regenGraphic();
        
        // then draw that on-top of the blurred text
        // basically giving it a glow effect
        final matrix:Matrix = new Matrix();
        matrix.translate(6, 6);
        textGlowBitmap.draw(textGraphic.pixels, matrix);

        // then finally, use that bitmap on a sprite
        final text:TrackingSprite = new TrackingSprite();
        text.loadGraphic(FlxGraphic.fromBitmapData(textGlowBitmap));
        text.tracked = capsule;
        text.trackingMode = 4; // 4 = DIRECT
        text.trackingOffset.set(88, 26);
        text.copyAlpha = false;
        text.clipRect = new FlxRect();
        Reflect.setProperty(text, "ID", i);
        // text.kill();
        text.update(0);
        grpSongNames.add(text);

        // make the character icon for this song
        var chosenIcon:String = "none";
        if(songMeta != null && songMeta.freeplay.icon != null)
            chosenIcon = songMeta.freeplay.icon;
        
        if(chosenIcon != "none") {
            final iconJsonPath:String = Paths.json('menus/freeplay/icons/${chosenIcon}');
            final iconConfig:Dynamic = (FlxG.assets.exists(iconJsonPath)) ? Json.parse(FlxG.assets.getText(iconJsonPath)) : {offset: [0, 0]};

            final songIcon:TrackingSprite = new TrackingSprite();
            songIcon.tracked = capsule;
            songIcon.trackingMode = 4; // 4 = DIRECT
            songIcon.trackingOffset.set(iconConfig.offset[0] - 4, iconConfig.offset[1] - 2);
            songIcon.loadSparrowFrames('menus/freeplay/icons/${chosenIcon}');
            songIcon.anim.addByPrefix('idle', 'idle', 12, true);
            songIcon.anim.addByPrefix('confirm', 'confirm0', 12, false);
            songIcon.anim.play('idle');
            songIcon.antialiasing = false;
            songIcon.setScale(2, FlxAxes.XY);
            Reflect.setProperty(songIcon, "ID", i); // rulescript.
            grpSongIcons.add(songIcon);
        }

        // make the rank icon (along with it's sparkle if it's a golden P rank icon)
        final rankIcon:TrackingSprite = new TrackingSprite();
        rankIcon.tracked = capsule;
        rankIcon.trackingMode = 4; // 4 = DIRECT
        rankIcon.trackingOffset.set(356, 28);
        rankIcon.copyAlpha = false;
        rankIcon.loadSparrowFrames('menus/freeplay/rank_badges');
        rankIcon.anim.addByPrefix('idle', 'GOLD rank', 24, false);
        rankIcon.anim.play('idle');
        rankIcon.anim.finish();
        rankIcon.setScale(0.9, FlxAxes.XY);
        Reflect.setProperty(rankIcon, "ID", i); // rulescript
        grpCapsuleExtras.add(rankIcon);
        
        // make the favorite icon
        final favIcon:TrackingSprite = new TrackingSprite();
        favIcon.tracked = capsule;
        favIcon.trackingMode = 4; // 4 = DIRECT
        favIcon.trackingOffset.set(316, 28);
        favIcon.copyAlpha = false;
        favIcon.loadSparrowFrames('menus/freeplay/favorite');
        favIcon.anim.addByPrefix('idle', 'favorite heart', 24, false);
        favIcon.anim.play('idle');
        favIcon.anim.finish();
        Reflect.setProperty(favIcon, "ID", i); // rulescript
        grpCapsuleExtras.add(favIcon);

        capsuleBadges.push([rankIcon, favIcon]);
        
        // we don't need the text object from earlier anymore,
        // KILL IT WITH FIRE ðŸ”¥ðŸ”¥ðŸ”¥
        textGraphic.destroy();
    }
}

function updateAlbumDisplay():Void {
    albumCover.visible = curSelected > 0;
    albumTitle.visible = curSelected > 0;
    difficultyStars.grp.visible = curSelected > 0;
    
    if(curAlbum == lastAlbum)
        return;

    if(curAlbum != null) {
        albumCover.loadGraphic(Paths.image('menus/freeplay/album/${curAlbum}/album'));
        albumTitle.loadGraphic(Paths.image('menus/freeplay/album/${curAlbum}/title'));

        difficultyStars.stars.y = difficultyStars.grp.y + 5;
        
        for(i in 0...difficultyStars.flames.length) {
            final flame:FlxSprite = difficultyStars.flames.members[i];
            flame.frameOffset.y = -5;
        }
        albumCover.frameOffset.y = -5;
        albumTitle.frameOffset.y = -5;

        albumCover.visible = true;
        albumTitle.visible = true;

        difficultyStars.visible = true;

        new FlxTimer().start((1 / 12) * 1, (_) -> {
            difficultyStars.stars.y = difficultyStars.grp.y;
            
            for(i in 0...difficultyStars.flames.length) {
                final flame:FlxSprite = difficultyStars.flames.members[i];
                flame.frameOffset.y = 0;
            }
            albumCover.frameOffset.y = 0;
            albumTitle.frameOffset.y = 0;
        });
    } else {
        albumCover.visible = false;
        albumTitle.visible = false;
        difficultyStars.visible = false;
    }
    lastAlbum = curAlbum;
}

function updateDifficultyDisplay():Void {
    final thing:String = 'menus/freeplay/difficulties/${currentMix ?? "default"}/${currentDifficulty}';
    final xmlPath:String = Paths.xml(thing);
    if(FlxG.assets.exists(xmlPath)) {
        diffDisplay.frames = Paths.getSparrowAtlas(thing);
        diffDisplay.animation.addByPrefix("idle", "idle", 24);
        diffDisplay.animation.play("idle");
    } else
        diffDisplay.loadGraphic(Paths.image(thing));
    
    diffDisplay.offset.set(diffDisplay.width * 0.5, diffDisplay.height * 0.5);
}

function updateDifficultyStars() {
    if(curSelected == 0) {
        difficultyStars.setDifficulty(0);
        return;
    }
    final songMixMeta:SongMetadata = (accessibleSongs[curSelected]?.metadata != null) ? accessibleSongs[curSelected].metadata.get(currentMix) : null;
    difficultyStars.setDifficulty((songMixMeta?.freeplay?.ratings != null) ? (songMixMeta.freeplay.ratings.get(currentDifficulty) ?? 0) : 0);
}

function updateDiscordRPC() {
    final lastSongData:FreeplaySongData = accessibleSongs[curSelected];
    final songMixMeta:SongMetadata = (accessibleSongs[curSelected]?.metadata != null) ? accessibleSongs[curSelected].metadata.get(currentMix) : null;
    DiscordRPC.changePresence("Freeplay Menu", '${(songMixMeta?.song != null) ? songMixMeta.song.title : ((lastSongData?.id != null) ? lastSongData.id : "Unknown")} [${currentDifficulty.toUpperCase()} - ${currentMix.toUpperCase()}]');
    
    vsliceFreeplay_lastSelected = curSelected;
    vsliceFreeplay_lastSongFilter = curSongFilter;
    vsliceFreeplay_lastDifficulty = currentDifficulty;
    vsliceFreeplay_lastMix = currentMix;
}

function updateOtherShit() {
    updateDifficultyDisplay();
    
    if(lastDifficulty != currentDifficulty || lastMix != currentMix) {
        diffDisplay.y = 115 - 15;
        FlxTween.completeTweensOf(diffDisplay);
        FlxTween.tween(diffDisplay, {y: 115}, 0.1, {ease: FlxEase.cubeOut});
        
        lastDifficulty = currentDifficulty;
        lastMix = currentMix;
    }
    final songMixMeta:SongMetadata = (accessibleSongs[curSelected]?.metadata != null) ? accessibleSongs[curSelected].metadata.get(currentMix) : null;
    curAlbum = (songMixMeta?.freeplay != null) ? songMixMeta.freeplay.album : "vol1";
    updateAlbumDisplay();
    updateDifficultyStars();
}

function changeSelection(?by:Int, ?force:Bool) {
    by ??= 0;
    force ??= false;

    if(by == 0 && !force)
        return;

    curSelected = FlxMath.wrap(curSelected + by, 0, grpCapsules.length - 1);
    grpCapsules.forEach((capsule) -> {
        if(capsule.ID == curSelected)
            capsule.anim.play('selected');
        else
            capsule.anim.play('idle');
    });
    grpSongNames.forEach((text) -> {
        if(text.ID == curSelected)
            text.alpha = 1;
        else
            text.alpha = 0.6;
    });
    grpCapsuleExtras.forEach((obj) -> {
        if(obj.ID == curSelected)
            obj.alpha = 1;
        else
            obj.alpha = 0.6;
    });
    totalTime = 0;
    changeDifficulty(0, true);
    updateDiscordRPC();

    if(!force)
        FlxG.sound.play(Paths.sound("menus/sfx/scroll"));
}

function changeFilter(?by:Int, ?force:Bool) {
    by ??= 0;
    force ??= false;

    if(by == 0 && !force)
        return;

    curSongFilter = FlxMath.wrap(curSongFilter + by, 0, songFilters.length - 1);
    for(i in 0...grpCategories.length) {
        final category:FunkinSprite = grpCategories.members[i];

        category.anim.addBySymbol("move", songFilters[FlxMath.wrap(curSongFilter + (i - 2), 0, songFilters.length - 1)] + " move", 24, false);
        category.anim.play("move");
        
        if(i != 2)
            category.anim.pause();
        else
            category.anim.resume();
        
        category.setPosition(grpCategories.x + (i * 80) + 10, grpCategories.y + -28);
        category.updateHitbox();
    }
    regenCapsules(songFilters[curSongFilter]);
    if(accessibleSongs.length <= 1) {
        curSelected = 0;
        changeSelection(0, true);
    }
    var updateSel:Bool = false;
    while(curSelected >= accessibleSongs.length) {
        curSelected--;
        updateSel = true;
    }
    if(updateSel)
        changeSelection(0, true);

    changeDifficulty(0, true);
    changeMix(0, true);
}

function changeDifficulty(?by:Int, ?force:Bool) {
    by ??= 0;
    force ??= false;

    if(by == 0 && !force)
        return;

    final selectedRandom:Bool = curSelected == 0;
    if(selectedRandom)
        curSelected = (accessibleSongs.length > 1) ? 1 : 0; // assume first song if possible

    final capsule:SongCapsule = grpCapsules.members[curSelected];
    final songMeta:ChartMetadata = (accessibleSongs[curSelected]?.metadata != null) ? accessibleSongs[curSelected].metadata.get("default") : null;
    
    var currentMixIndex:Int = (songMeta?.song != null) ? songMeta.song.mixes.indexOf(currentMix) : -1;
    currentMix = (songMeta?.song != null) ? songMeta.song.mixes[currentMixIndex] : "default";

    final songMixMeta:ChartMetadata = (accessibleSongs[curSelected]?.metadata != null) ? accessibleSongs[curSelected].metadata.get(currentMix) : null;
    final diffs:Array<String> = (songMixMeta?.song != null) ? songMixMeta.song.difficulties : ["easy", "normal", "hard"];
    
    var currentDifficultyIndex:Int = diffs.indexOf(currentDifficulty);
    currentDifficultyIndex += by;
    currentDifficulty = diffs[currentDifficultyIndex];

    if(selectedRandom)
        curSelected = 0;

    if(currentDifficultyIndex < 0) {
        changeMix(-1);
        final songMixMeta:ChartMetadata = (accessibleSongs[curSelected]?.metadata != null) ? accessibleSongs[curSelected].metadata.get(currentMix) : null;
        final variantDiffs:Array<String> = (songMixMeta?.song != null) ? songMixMeta.song.difficulties : diffs;
        currentDifficulty = variantDiffs[variantDiffs.length - 1];
    }
    else if(currentDifficultyIndex > diffs.length - 1) {
        changeMix(1);
        final songMixMeta:ChartMetadata = (accessibleSongs[curSelected]?.metadata != null) ? accessibleSongs[curSelected].metadata.get(currentMix) : null;
        final variantDiffs:Array<String> = (songMixMeta?.song != null) ? songMixMeta.song.difficulties : diffs;
        currentDifficulty = variantDiffs[0];
    }
    updateOtherShit();
    updateDiscordRPC();
}

function changeMix(?by:Int = 0, ?force:Bool = false):Void {
    if(by == 0 && !force)
        return;

    final capsule:SongCapsule = grpCapsules.members[curSelected + 1];

    final lastSongData:FreeplaySongData = accessibleSongs[curSelected];
    final songMeta:ChartMetadata = (lastSongData?.metadata != null) ? lastSongData.metadata.get("default") : null;
    
    var currentMixIndex:Int = (songMeta?.song != null) ? songMeta.song.mixes.indexOf(currentMix) : -1;
    if(songMeta != null && songMeta.song.mixes.length != 0)
        currentMixIndex = FlxMath.wrap(currentMixIndex + by, 0, songMeta.song.mixes.length - 1);
    else
        currentMixIndex = 0;

    currentMix = (songMeta?.song != null) ? songMeta.song.mixes[currentMixIndex] : "default";
    
    final songMixMeta:ChartMetadata = (accessibleSongs[curSelected]?.metadata != null) ? accessibleSongs[curSelected].metadata.get(currentMix) : null;
    final diffs:Array<String> = (songMixMeta?.song != null) ? songMixMeta.song.difficulties : ["easy", "normal", "hard"];
    
    var currentDifficultyIndex:Int = diffs.indexOf(currentDifficulty);
    currentDifficultyIndex = FlxMath.wrap(currentDifficultyIndex + by, 0, diffs.length - 1);
    currentDifficulty = diffs[currentDifficultyIndex];
    
    if(lastMix != currentMix)
        regenCapsules(songFilters[curSongFilter]);
    
    updateOtherShit();
    for(i in 0...accessibleSongs.length) {
        final songData:FreeplaySongData = accessibleSongs[i];
        if(songData.id == lastSongData.id) {
            curSelected = i;
            break;
        }
    }
    changeSelection(0, true);
    updateDiscordRPC();
}

function updateCapsule(capsule:FunkinSprite) {
    final index:Int = capsule.ID - curSelected;

    final lerpAmountX:Float = FlxMath.getElapsedLerp(0.3, FlxG.elapsed);
    final lerpAmountY:Float = FlxMath.getElapsedLerp(0.4, FlxG.elapsed);

    capsule.setPosition(
        FlxMath.lerp(capsule.x - capsuleData.offsetX, 335 + Math.sin(index + 1) * 60 - (index > 3 ? 50 : 0), lerpAmountX),
        FlxMath.lerp(capsule.y, 250 + (index * 115) - (index < -1 ? 100 : 0), lerpAmountY)
    );
    capsule.x += capsuleData.offsetX;
}

function updateSongName(songName:TrackingSprite) {
    var visibleBadges:Int = 0;
    for(b in capsuleBadges[songName.ID]) {
        if(b.exists && b.visible)
            visibleBadges++;
    }
    final textWidth:Float = 366 - (visibleBadges * 70);
    if(visibleBadges > 0) {
        songName.trackingOffset.x = 88 - ((curSelected == songName.ID && songName.width > textWidth) ? (Math.sin(totalTime * 0.9) * (songName.width - textWidth) * 0.5) + ((songName.width - textWidth) * 0.5) : 0);
        songName.clipRect.set(-(songName.trackingOffset.x - 88), 0, textWidth, songName.frameHeight);
    } else {
        songName.trackingOffset.x = 88;
        songName.clipRect.set(0, 0, 366, songName.frameHeight);
    }
}

function switchState(nextState:NextState) {
    if(FlxG.state == super) {
        final shit = Type.createInstance(TransitionableState.defaultTransOut, []);
        openSubState(shit);

        shit.finishCallback = () -> FlxG.switchState(nextState);
        shit.start(0);
    } else
        FlxG.switchState(nextState);
}

function loadIntoCharter():Void {
    final songData:FreeplaySongData = accessibleSongs[curSelected];
    switchState(() -> new ChartEditor({
        song: songData.id,
        difficulty: currentDifficulty,
        mix: currentMix,
        mod: songData.contentPack
    }));
}

function loadIntoSong():Void {
    final songData:FreeplaySongData = accessibleSongs[curSelected];
    PlayState.deathCounter = 0;
    switchState(() -> new PlayState({
        song: songData.id,
        difficulty: currentDifficulty,
        mix: currentMix,
        mod: songData.contentPack
    }));
}

function callOntoDJ(method:String, ?args:Array<Dynamic>) {
    if(djScript != null)
        djScript.call(method, args);
}

function makeDifficultyStars(x:Float, y:Float):DifficultyStars {
    final flameX:Float = 917;
    final flameY:Float = 103;

    final flameSpreadX = 29;
    final flameSpreadY = 6;

    final flameTimer:Float = 0.25;

    final ret:DifficultyStars = {
        grp: new FlxSpriteGroup(x, y), // containing the next 2 variables

        flames: null,
        stars: null,

        difficulty: 1,
        curDifficulty: 0,

        flameCount: 0,
        timers: [],

        flameX: flameX,
        flameY: flameY,

        flameSpreadX: flameSpreadX,
        flameSpreadY: flameSpreadY,

        positionedFlames: false
    };
    ret.setFlameCount = (value:Int) -> {
        // Stop all existing timers.
		// This fixes a bug where quickly switching difficulties would show flames.
		for(timer in ret.timers.copy()) {
			timer.cancel();
			ret.timers.remove(timer);
		}
		ret.flameCount = value;

		var visibleCount:Int = 0;
		for(i in 0...5) {
			if(ret.flames.members[i] == null)
				continue;

			var flame:FlxSprite = ret.flames.members[i];
			if(i < ret.flameCount) {
				if(!flame.exists) {
					var nextTimer:FlxTimer = new FlxTimer().start(flameTimer * visibleCount, (currentTimer:FlxTimer) -> {
						if(i >= ret.flameCount)
							return;
						
						ret.timers.remove(currentTimer);
						flame.animation.play("flame", true);
						flame.exists = true;
					});
					ret.timers.push(nextTimer);
					visibleCount++;
				}
			}
            else
				flame.exists = false;
		}
    };
    ret.flameCheck = () -> {
        if(ret.difficulty > 10)
            ret.setFlameCount(ret.difficulty - 10);
        else
            ret.setFlameCount(0);
    };
    ret.flames = new FlxSpriteGroup();
    for(i in 0...5) {
        var flame:FlxSprite = new FlxSprite(flameX + (flameSpreadX * i), flameY + (flameSpreadY * i));
        flame.frames = Paths.getSparrowAtlas("menus/freeplay/flame");
        flame.animation.addByPrefix("flame", "fire loop full instance 1", FlxG.random.int(23, 25), false);
        flame.animation.play("flame");
        // flame.makeSolid(50, 50, FlxColor.WHITE);
        flame.exists = false;
        ret.setFlameCount(0);

        // sets the loop... maybe better way to do this lol!
        flame.animation.onFinish.add((_) -> {
            flame.animation.play("flame", true, false, 2);
        });
        ret.flames.add(flame);
    }
    ret.grp.add(ret.flames);

    ret.stars = new FunkinSprite();
    ret.stars.loadAnimateFrames("menus/freeplay/stars");
    ret.stars.anim.addBySymbol("stars", "diff stars", 24, false);
    ret.stars.anim.play("stars");
    ret.grp.add(ret.stars);

    ret.setDifficulty = (value:Int) -> {
        if(value <= 0) {
            ret.difficulty = 0;
			ret.curDifficulty = 15;
		} else if(value <= 15) {
            ret.difficulty = value;
			ret.curDifficulty = ret.difficulty - 1;
		} else {
			ret.difficulty = 15;
			ret.curDifficulty = ret.difficulty - 1;
		}
        if(ret.curDifficulty == 15) {
            ret.stars.anim.play("stars", true, false, 1500);
            ret.stars.anim.pause();
        } else {
            ret.stars.anim.play("stars", true, false, Std.int(ret.curDifficulty * 100));
            ret.stars.anim.curAnim.curFrame = Std.int(ret.curDifficulty * 100);
        }
		ret.flameCheck();
    };
    return ret;
}

function onAccept() {
    if(curSelected == 0) {
        // 1st entry is always "Random", so select a random song!
        curSelected = FlxG.random.int(1, grpCapsules.length - 1);
        changeSelection(0, true);
    }
    if(grpCapsules.length < 2) {
        for(spr in [grpCapsules.members[curSelected], grpSongNames.members[curSelected]]) {
            spr.updateHitbox();
            FlxTween.cancelTweensOf(spr);
            FlxTween.shake(spr, 0.01, 0.16, FlxAxes.XY);
        }
        FlxG.sound.play(Paths.sound("menus/sfx/cancel"));
        return;
    }
    accepted = true;
    callOntoDJ("onAccept");
    callOntoDJ("onConfirm");
    callOntoDJ("onConfirmSong");
    callOntoDJ("onSongConfirm");

    FlxTimer.wait(1.5, () -> {
        if(FlxG.state.subState != null) {
            FlxG.state.persistentDraw = true;
            FlxG.state.subState = null;
            FlxG.state.add(super);
            Reflect.setProperty(super, "_parentState", null);
        }
        FlxTimer.wait(0.001, () -> {
            if(FlxG.keys.pressed.SHIFT)
                loadIntoCharter();
            else
                loadIntoSong();

            if(FlxG.sound.music != null)
                FlxG.sound.music.fadeOut(0.16, 0);
        });
    });
    grpSongIcons.forEach((icon) -> {
        if(icon.ID == curSelected)
            icon.anim.play("confirm");
    });
    FlxG.sound.play(Paths.sound("menus/sfx/select"));
}

function onExit() {
    FlxG.state.persistentDraw = true;
    callOntoDJ("onExit");
    callOntoDJ("onCancel");

    pinkBG.revive();
    FlxTween.tween(capsuleData, {offsetX: FlxG.width}, 0.5, {ease: FlxEase.cubeIn});
    
    // left side
    FlxTween.tween(dj, {x: -dj.width}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(pinkBG, {x: -pinkBG.width}, 0.5, {ease: FlxEase.cubeIn});

    FlxTween.tween(diffDisplay, {x: diffDisplay.x - pinkBG.width}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(diffLeftSelector, {x: diffLeftSelector.x - pinkBG.width}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(diffRightSelector, {x: diffRightSelector.x - pinkBG.width}, 0.5, {ease: FlxEase.cubeIn});
    
    // right side
    FlxTween.tween(dadCover, {x: FlxG.width}, 0.5, {ease: FlxEase.cubeIn});

    FlxTween.tween(albumCover, {x: albumCover.x + dadCover.width}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(albumTitle, {x: albumTitle.x + dadCover.width}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(difficultyStars.grp, {x: difficultyStars.grp.x + dadCover.width}, 0.5, {ease: FlxEase.cubeIn});

    // top
    FlxTween.tween(header, {y: -(header.height * 2)}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(headerFreeplayText, {y: headerFreeplayText.y - (header.height * 2)}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(headerOSTText, {y: headerOSTText.y - (header.height * 2)}, 0.5, {ease: FlxEase.cubeIn});

    FlxTween.tween(grpCategoryArrows, {y: grpCategoryArrows.y - (header.height * 2)}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(grpCategorySeparators, {y: grpCategorySeparators.y - (header.height * 2)}, 0.5, {ease: FlxEase.cubeIn});
    FlxTween.tween(grpCategories, {y: grpCategories.y - (header.height * 2)}, 0.5, {ease: FlxEase.cubeIn});

    if(FlxG.sound.music != null)
        FlxG.sound.music.fadeOut(0.5, 0.0);

    FlxTimer.wait(0.55, () -> {
        if(FlxG.state == super) {
            FlxG.game._state = members[0];
            FlxG.game._state.active = true;
            FlxG.game._state._cameras = null;

            remove(members[0], true);
            super.destroy();
        } else {
            FlxG.state.updateDiscordRPC();
            close();
        }
        CoolUtil.playMenuMusic();
    });
    FlxG.sound.play(Paths.sound("menus/sfx/cancel"));
}

function onCreate() {
    persistentUpdate = true;

    for(contentPack in Paths.getEnabledContentPacks()) {
        final contentMetadata:ContentMetadata = Paths.contentMetadata.get(contentPack);
        if(contentMetadata == null)
            continue; // if no metadata was found for this content pack, then don't bother
        
        for(category in contentMetadata.freeplayCategories) {
            categories.push({
                id: '${contentPack}:${category.id}',
                name: category.name
            });
            categoryMap.set('${contentPack}:${category.id}', category);
        }
        for(level in contentMetadata.levels) {
            if(!level.showInFreeplay)
                continue;

            final categoryID:String = '${contentPack}:${level.freeplayCategory}';
            if(!songListMap.exists(categoryID))
                songListMap.set(categoryID, []);

            final validSongs:Array<String> = [];
            for(song in level.songs) {
                if(level.hiddenSongs.freeplay.contains(song))
                    continue;

                if(!FlxG.assets.exists(Paths.json('gameplay/songs/${song}/default/metadata', contentPack)))
                    continue;

                validSongs.push(song);
            }
            addSongsToCategory(level.freeplayCategory, validSongs, contentPack);
        }
    }
    pinkBG = new FunkinSprite().loadGraphic(Paths.image("menus/freeplay/pink_bg"));
    pinkBG.x = -pinkBG.width;
    pinkBG.screenCenter(FlxAxes.Y);
    add(pinkBG);

    final djScriptPath:String = Paths.script('menus/freeplay/dj/${curCharacter}/script');
    if(FlxG.assets.exists(djScriptPath)) {
        djScript = FunkinScript.fromFile(djScriptPath);
        djScript.set("menu", super);
        djScript.set("djName", curCharacter);
        djScript.set("curCharacter", curCharacter);
        djScript.set("curMenuDJ", curCharacter);
        djScript.set("curDJ", curCharacter);
        djScript.execute();

        djScript.call("new");
        djScript.call("onLoad");

        dj = djScript.call("initDJ");
        djScript.call("playIntro");

        super.subStateScripts.add(djScript);
    }
    dadCover = new FunkinSprite().loadGraphic(Paths.image('menus/freeplay/covers/dad${(curCharacter != "bf") ? '-${curCharacter}' : ""}'));
    dadCover.x = FlxG.width;
    dadCover.screenCenter(FlxAxes.Y);
    dadCover.color = FlxColor.BLACK;
    add(dadCover);

    albumCover = new FunkinSprite(FlxG.width - 330, 0);
    albumCover.loadGraphic(Paths.image("menus/freeplay/album/vol1/album"));
    albumCover.screenCenter(FlxAxes.Y);
    albumCover.angle = 10;
    albumCover.y += 55;
    albumCover.kill();
    add(albumCover);

    albumTitle = new FunkinSprite(albumCover.x - 25, albumCover.y + 216);
    albumTitle.loadGraphic(Paths.image("menus/freeplay/album/vol1/title"));
    albumTitle.kill();
    add(albumTitle);

    difficultyStars = makeDifficultyStars(955, 220);
    add(difficultyStars.grp);

    grpCapsules = new FlxTypedGroup();
    add(grpCapsules);

    grpSongNames = new FlxTypedGroup();
    add(grpSongNames);

    grpSongIcons = new FlxTypedGroup();
    add(grpSongIcons);

    grpCapsuleExtras = new FlxTypedGroup();
    add(grpCapsuleExtras);

    diffDisplay = new FunkinSprite(197, 115);
    diffDisplay.loadGraphic(Paths.image("menus/freeplay/difficulties/default/hard"));
    diffDisplay.kill();
    add(diffDisplay);
    
    diffLeftSelector = new FunkinSprite(20, 70);
    diffLeftSelector.frames = Paths.getSparrowAtlas('menus/freeplay/skins/${curCharacter}/selector');
    diffLeftSelector.animation.addByPrefix("idle", "arrow pointer loop", 24);
    diffLeftSelector.animation.play("idle");
    diffLeftSelector.kill();
    add(diffLeftSelector);
    
    diffRightSelector = new FunkinSprite(325, 70);
    diffRightSelector.frames = Paths.getSparrowAtlas('menus/freeplay/skins/${curCharacter}/selector');
    diffRightSelector.animation.addByPrefix("idle", "arrow pointer loop", 24);
    diffRightSelector.animation.play("idle");
    diffRightSelector.flipX = true;
    diffRightSelector.kill();
    add(diffRightSelector);

    grpCategoryArrows = new FlxTypedSpriteGroup();
    grpCategoryArrows.setPosition(380, 90);
    grpCategoryArrows.kill();
    add(grpCategoryArrows);

    grpCategorySeparators = new FlxTypedSpriteGroup();
    grpCategorySeparators.setPosition(grpCategoryArrows.x, grpCategoryArrows.y);
    grpCategorySeparators.kill();
    add(grpCategorySeparators);
    
    grpCategories = new FlxTypedSpriteGroup();
    grpCategories.setPosition(grpCategoryArrows.x, grpCategoryArrows.y);
    grpCategories.kill();
    add(grpCategories);

    for(i in 0...4) {
        final sep:FunkinSprite = new FunkinSprite().loadGraphic(Paths.image("menus/freeplay/separator"));
        sep.setPosition((i * 80) + 80, 4);
        grpCategorySeparators.add(sep);
    }
    for(i in 0...5) {
        final category:FunkinSprite = new FunkinSprite();
        category.loadAnimateFrames("menus/freeplay/categories");
        category.setPosition((i * 80) + 70, 35);

        category.anim.addBySymbol("move", songFilters[FlxMath.wrap(curSongFilter + (i - 2), 0, songFilters.length - 1)] + " move", 24, false);
        category.anim.play("move");

        var darkness:Float = Math.abs(i - 2) / 6;
        category.color = new FlxColor(0xFFFFFFFF).getDarkened(darkness);
        
        if(i != 2) {
            category.scale.set(0.8, 0.8);
            category.updateHitbox();
            category.anim.pause();
        }
        grpCategories.add(category);
    }
    categoryLeftArrow = new FunkinSprite().loadGraphic(Paths.image("menus/freeplay/mini_arrow"));
    categoryLeftArrow.scale.set(0.7, 0.7);
    categoryLeftArrow.updateHitbox();
    categoryLeftArrow.flipX = true;
    grpCategoryArrows.add(categoryLeftArrow);

    categoryRightArrow = new FunkinSprite().loadGraphic(Paths.image("menus/freeplay/mini_arrow"));
    categoryRightArrow.x = 400;
    categoryRightArrow.scale.set(0.7, 0.7);
    categoryRightArrow.updateHitbox();
    grpCategoryArrows.add(categoryRightArrow);

    header = new FunkinSprite().makeSolid(FlxG.width, 65, 0xFF000000);
    header.y -= header.height;
    add(header);
    
    headerFreeplayText = new FlxText(10, 6, 0, "FREEPLAY");
    headerFreeplayText.setFormat(Paths.font("fonts/vcr"), 48);
    headerFreeplayText.y -= header.height;
    headerFreeplayText.kill();
    add(headerFreeplayText);
    
    headerOSTText = new FlxText(FlxG.width - 10, 6, 0, "OFFICIAL OST");
    headerOSTText.setFormat(Paths.font("fonts/vcr"), 48);
    headerOSTText.x -= headerOSTText.width;
    headerOSTText.y -= header.height;
    headerOSTText.kill();
    add(headerOSTText);

    curSelected = vsliceFreeplay_lastSelected;
    curSongFilter = vsliceFreeplay_lastSongFilter;
    currentDifficulty = vsliceFreeplay_lastDifficulty;
    currentMix = vsliceFreeplay_lastMix;

    changeFilter(0, true);
    difficultyStars.grp.visible = false;

    // final refImg:FlxSprite = new FlxSprite().loadGraphic(Paths.image('${ext}/reference'));
    // refImg.alpha = 0.25;
    // refImg.screenCenter();
    // add(refImg);

    camera = new FlxCamera();
    camera.bgColor = 0;
    FlxG.cameras.add(camera, false);

    FlxTween.tween(pinkBG, {x: 0}, 0.5, {ease: FlxEase.cubeOut});
    FlxTween.tween(dadCover, {x: FlxG.width - dadCover.width}, 0.5, {ease: FlxEase.cubeOut});

    for(obj in [header, headerFreeplayText, headerOSTText])
        FlxTween.tween(obj, {y: obj.y + header.height}, 0.5, {ease: FlxEase.cubeOut});

    FlxTimer.wait(0.5, () -> {
        playingIntro = false;

        if(parent != null)
            parent.persistentDraw = false;

        pinkBG.kill();
        dadCover.color = FlxColor.WHITE;

        headerFreeplayText.revive();
        headerOSTText.revive();
        
        diffDisplay.x = -diffDisplay.width;
        FlxTween.tween(diffDisplay, {x: 197}, 0.5, {ease: FlxEase.cubeOut});
        
        diffDisplay.revive();
        diffLeftSelector.revive();
        diffRightSelector.revive();

        grpCategoryArrows.revive();
        grpCategorySeparators.revive();
        grpCategories.revive();

        albumCover.revive();
        albumCover.x = FlxG.width - 50;
        albumCover.angle = 15;

        // this is messy and stupid and not fully accurate
        // but i don't care it's good enough
        new FlxTimer().start((1 / 12) * 1, (_) -> {
            albumCover.x = FlxG.width - 350;
            albumCover.angle = 5;
        });
        new FlxTimer().start((1 / 12) * 2, (_) -> {
            albumCover.x = FlxG.width - 330;
            albumCover.angle = 10;

            difficultyStars.grp.visible = curSelected != 0;
            updateDifficultyStars();
        });
        new FlxTimer().start((1 / 12) * 4, (_) -> {
            albumTitle.revive();
            albumTitle.scale.set(1.1, 0.9);
        });
        new FlxTimer().start((1 / 12) * 5, (_) -> {
            albumTitle.scale.set(1, 1);
        });
        dadCover.colorTransform.redMultiplier = 0;
        dadCover.colorTransform.greenMultiplier = 0;
        dadCover.colorTransform.blueMultiplier = 0;

        FlxTween.tween(dadCover.colorTransform, {redMultiplier: 1, greenMultiplier: 1, blueMultiplier: 1}, 0.25, {ease: FlxEase.cubeOut});
        callOntoDJ("showBackingCard");
    });
}

function onCreatePost() {
    if(FlxG.state == super) {
        final shit = Type.createInstance(TransitionableState.defaultTransIn, []);
        
        var state:FlxState = super;
        while(state.subState != null)
            state = state.subState;
        
        state.openSubState(shit);

        shit.finishCallback = shit.close;
        shit.start(1);
    }
}

function onUpdatePre(dt:Float) {
    if(!goMyFreeplay) {
        goMyFreeplay = true;
        return;
    }
    if(FlxG.keys.justPressed.END) {
        if(parent != null)
            parent.persistentDraw = true;

        close();
    }
    if(!accepted && !playingIntro) {
        final wheel:Float = -FlxG.mouse.wheel;
        if(controls.justPressed.check(Control.UI_UP) || wheel < 0)
            changeSelection(-1);
    
        if(controls.justPressed.check(Control.UI_DOWN) || wheel > 0)
            changeSelection(1);

        if(controls.justPressed.check(Control.UI_LEFT))
            changeDifficulty(-1);

        if(controls.justPressed.check(Control.UI_RIGHT))
            changeDifficulty(1);

        if(FlxG.keys.justPressed.Q)
            changeFilter(-1);

        if(FlxG.keys.justPressed.E)
            changeFilter(1);
    
        if(controls.justPressed.check(Control.BACK)) {
            accepted = true;
            if(FlxG.game._state == super) {
                final constructor = () -> new MainMenuState();
                
                final menu:MainMenuState = constructor();
                Reflect.setProperty(menu, "_constructor", constructor); // constructor must be set otherwise FlxG.resetState won't work
                menu.create();
                menu.createPost();

                menu.active = false;
                menu.cameras = [FlxG.camera];
                insert(0, menu);
            }
            onExit();
        }
        if(controls.justPressed.check(Control.ACCEPT))
            onAccept();
    }
    grpCapsules.forEach(updateCapsule);
    grpSongNames.forEach(updateSongName);
    totalTime += dt;
}

function onUpdatePost(dt:Float) {
    if(difficultyStars.curDifficulty < 15 && difficultyStars.stars.anim.curAnim.curFrame >= (difficultyStars.curDifficulty + 1) * 100)
		difficultyStars.stars.anim.play("stars", true, false, difficultyStars.curDifficulty * 100);

    if(!difficultyStars.positionedFlames) {
        for(i in 0...5) {
            difficultyStars.flames.members[i].x = difficultyStars.flameX + (difficultyStars.flameSpreadX * i);
            difficultyStars.flames.members[i].y = difficultyStars.flameY + (difficultyStars.flameSpreadY * i);
        }
        difficultyStars.positionedFlames = true;
    }
}

function onDestroy() {
    FlxG.cameras.remove(camera);
}