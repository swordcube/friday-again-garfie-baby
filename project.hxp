package;

import hxp.*;
import lime.tools.*;

import sys.FileSystem;
import sys.io.File;
import haxe.io.Path;
import haxe.ds.Map;

using StringTools;

class Project extends HXProject {
	static final ANDROID_MINIMUM_SDK_VERSION:Int = 28;
	static final ANDROID_TARGET_SDK_VERSION:Int = 34;

	static final SOURCE_DIR:String = "source";
	static final ANDROID_EXTENSIONS:Array<String> = ["funkin.extensions.CallbackUtil"];

	static var astcExcludes:Array<String> = [];

	public function new() {
		super();

		astcExcludes = File.getContent('./compression-excludes.txt').trim().split('\n');

		for (i in 0...astcExcludes.length)
			astcExcludes[i] = astcExcludes[i].trim();

		// [ app config ] //

		meta.title = "friday again garfie baby";
		if(isIOS())
			meta.title = ~/ /ig.replace(meta.title, "\u2002"); // iOS is weird

		meta.version = "0.1.0";

		meta.packageName = "com.swordcube.GarfieBabyFunkin";
		meta.company = "swordcube";

		app.main = "funkin.backend.Main";
		app.file = "Funkin";

		if(isDebug())
			app.path = "export/debug";
		else
			app.path = "export/release";

		sources.push(SOURCE_DIR);

		// [ window config ] //

		window.fps = 144;
		window.width = (!isMobile()) ? 1280 : 0;
		window.height = (!isMobile()) ? 720 : 0;
		window.orientation = Orientation.LANDSCAPE;
		window.fullscreen = isMobile();
		window.borderless = isMobile();
		window.resizable = true;
		window.hardware = true;
		window.background = 0xFF000000;
		window.allowHighDPI = true;
		window.vsync = isMobile();

		// [ defines ] //

		// internal stuff, don't rly worry about it
		if (isDefined("TEST_BUILD"))
			setDefine("DEV_BUILD");

		// mobile ui define
		if (isMobile())
			setDefine("MOBILE_UI");

		// scripting (hscript & lua)
		if (!isDefined("NO_SCRIPTING") && !isDefined("NO_SCRIPTING_ALLOWED"))
			setDefine("SCRIPTING_ALLOWED");

		if (isDefined("SCRIPTING_ALLOWED") && !isDefined("NO_HSCRIPT") && !isDefined("NO_HSCRIPT_ALLOWED"))
			setDefine("HSCRIPT_ALLOWED");

		if (isDefined("SCRIPTING_ALLOWED") && !isDefined("NO_LUA") && !isDefined("NO_LUA_ALLOWED"))
			setDefine("LUA_ALLOWED");

		// discord rpc
		if (isCPP()
			&& isDesktop()
			&& !isDefined("NO_DISCORD")
			&& !isDefined("NO_DISCORD_RPC_ALLOWED")
			&& !isDefined("NO_DISCORD_ALLOWED"))
			setDefine("DISCORD_ALLOWED");

		// video playback
		
		// TODO: why does going into gameplay crash on mobile when this is defined?
		// it seems to crash during the loading of scripts, which is really odd

		if (isCPP() && !isMobile() && !isDefined("NO_VIDEOS") && !isDefined("NO_VIDEOS_ALLOWED"))
			setDefine("VIDEOS_ALLOWED");

		// crash handler
		if (!isDefined("NO_CRASH_HANDLER") && !isDefined("NO_CRASH_HANDLER_ALLOWED"))
			setDefine("CRASH_HANDLER");

		// windows crash handler
		if (isWindows() && !isDefined("NO_WINDOWS_CRASH_HANDLER") && !isDefined("NO_WINDOWS_CRASH_HANDLER_ALLOWED"))
			setDefine("WINDOWS_CRASH_HANDLER");

		// save crash logs
		if (isDefined("CRASH_HANDLER") && !isDefined("NO_SAVE_CRASH_LOGS") && !isDefined("NO_SAVE_CRASH_LOGS_ALLOWED"))
			setDefine("SAVE_CRASH_LOGS");

		// compile all classes
		if (isDefined("SCRIPTING_ALLOWED")
			&& !isDefined("NO_COMPILE_ALL_CLASSES")
			&& !isDefined("DONT_COMPILE_ALL_CLASSES")
			&& !isDefined("COMPILE_USED_CLASSES_ONLY"))
			setDefine("COMPILE_ALL_CLASSES");

		// moonchart
		if (!isDefined("NO_MOONCHART"))
			setDefine("USE_MOONCHART");

		// linux case insensitive files
		// i'm mad at myself for forgetting the isLinux() part
		if (isLinux() && !isDefined("NO_LINUX_CASE_INSENSITIVE_FILES") && !isDefined("LINUX_CASE_SENSITIVE_FILES"))
			setDefine("LINUX_CASE_INSENSITIVE_FILES");

		// [ assets ] //

		// ASTC asset compression
		// TODO: get astc asset compression working again...at some point
		// final noASTCCompress:Bool = Sys.getEnv("NO_ASTC_COMPRESSION") == "1";
		// if (isMobile() && !isDisplay() && !isDebug() && !noASTCCompress) {
		// 	final folders:Array<String> = ['assets', 'example_content'];
		// 	trace('Compressing folders: ${folders}');
		// 	for (f in folders) {
		// 		var args:Array<String> = ['run', 'astc-compressor', 'compress'];
		// 		args = args.concat(['-i', './${f}']);
		// 		args = args.concat(['-o', './astc-textures/']);
		// 		args = args.concat(['-blocksize', "10x10"]);
		// 		args = args.concat(['-quality', "medium"]);
		// 		args = args.concat(['-excludes', './compression-excludes.txt']);
		// 		args = args.concat(['-colorprofile', 'cl']);
		// 		Sys.command('haxelib', args);
		// 	}
		// }
		// add assets (if not on a test build)
		addAssetLibrary("default");

		if (!isDefined("TEST_BUILD") && !isDisplay()) {
			addAssetPath("assets", null, "default", ["*"]);
			addAssetPath("example_content", "content", "default", ["*"]);
		}
		// ALSoft configuration
		// Makes audio sound cleaner
		if (isDesktop()) {
			if (isWindows())
				addAsset("alsoft.ini", "plugins/alsoft.ini");
			else
				addAsset("alsoft.ini", "plugins/alsoft.conf");
		}
		// fix Linux compilation
		if (isDesktop())
			setDefine("NO_PRECOMPILED_HEADERS");
		
		if (isLinux() || isMac())
			addAsset("art/icons/256x.png", "icon.png"); // icon for Linux and macOS

		// [ haxelibs ] //

		// fix compilation issues with local haxelibs :[
		setenv("HAXEPATH", "./");

		// native file dialog (lime FileDialog sucks on linux)
		if (isDesktop() && isLinux())
			addHaxelib("hxnativefiledialog");

		// lime
		addHaxelib("hxp");
		addHaxelib("lime");
		addHaxelib("openfl");
		
		// haxeflixel
		addHaxelib("flixel");
		addHaxelib("flixel-addons");
		addHaxelib("flixel-controls");
		addHaxelib("flixel-animate");

		// android utils
		if (isAndroid())
			addHaxelib("extension-androidtools");

		// discord rpc
		if (isDefined("DISCORD_ALLOWED")) {
			addHaxelib("hxdiscord_rpc");
			setDefine("DISCORD_DISABLE_IO_THREAD");
		}
		// video playback
		if (isDefined("VIDEOS_ALLOWED"))
			addHaxelib("hxvlc");

		// thx.core / thx.semver
		addHaxelib("thx.core");
		addHaxelib("thx.semver");

		// json2object (parses to classes instead of dynamic objects)
		addHaxelib("json2object");

		// moonchart
		if (isDefined("USE_MOONCHART"))
			addHaxelib("moonchart");

		// scripting
		if (isDefined("SCRIPTING_ALLOWED")) {
			if (isDefined("LUA_ALLOWED")) {
				addHaxelib("linc_luajit"); // LuaJIT
				addHaxelib("lscript"); // Haxe OOP Lua wrapper
			}
			if (isDefined("HSCRIPT_ALLOWED")) {
				addHaxelib("hscript"); // HScript
				addHaxelib("rulescript"); // RuleScript (HScript extension)
			}
		}
		// remove the legacy health system
		setDefine("FLX_NO_HEALTH");

		// flixel 5.9.0+ custom assets system configuration
		setDefine("FLX_CUSTOM_ASSETS_DIRECTORY", "assets");
		setDefine("FLX_CUSTOM_RUNTIME_ASSETS_DIRECTORY");
		setDefine("FLX_NO_VALIDATE_CUSTOM_ASSETS_DIRECTORY");

		// disable focus lost screen
		setDefine("FLX_NO_FOCUS_LOST_SCREEN");

		// release build specific defines
		if (isRelease()) {
			// disable flixel debugger
			setDefine("FLX_NO_DEBUG");

			// performance improvements for nape (if used)
			setDefine("NAPE_RELEASE_BUILD");
		}
		// crash handler stuff
		if (isDefined("CRASH_HANDLER")) {
			setDefine("HXCPP_CHECK_POINTER");
			setDefine("HXCPP_STACK_LINE");
			setDefine("HXCPP_STACK_TRACE");
			setDefine("HXCPP_CATCH_SEGV");

			if (isMobile())
				setDefine("HXCPP_DEBUG_LINK");

			setDefine("openfl-enable-handle-error");
		}
		// disable a macro in lime that generates a random number for Assets.cache.version every build.
    	// this doesn't seem to be useful and it also makes lime.utils.AssetCache to be re-compiled on every build.
		setDefine("lime_disable_assets_version");

		// generational gc on desktop
		// if (isDesktop())
		// 	setDefine("HXCPP_GC_GENERATIONAL");

		// self explanatory
		setDefine("no-deprecation-warnings");

		// pretty syntax errors and stuff
		setDefine("message.reporting", "pretty");

		// better hscript errors
		setDefine("hscriptPos");

		// experimental update queue (performance thingie)
		setDefine("openfl_enable_experimental_update_queue");

		// compile all classes into executable (for scripting)
		if (isDefined("COMPILE_ALL_CLASSES")) {
			addHaxeFlag("-dce no");
			addHaxeMacro("funkin.backend.macros.IncludeMacro.build()");
		}
		// application icons
		addIcon("art/icons/16x.png", 16);

		addIcon("art/icons/32x.png", 24);
		addIcon("art/icons/32x.png", 32);

		addIcon("art/icons/64x.png", 40);
		addIcon("art/icons/64x.png", 48);
		addIcon("art/icons/64x.png", 64);

		addIcon("art/icons/256x.png", 96);
		addIcon("art/icons/256x.png", 128);
		addIcon("art/icons/256x.png", 196);
		addIcon("art/icons/256x.png", 256);
		addIcon("art/icons/256x.png", 512);
		addIcon("art/icons/256x.png", 768);
		addIcon("art/icons/256x.png", 1024);

		// android config
		if (isAndroid()) {
			// ensure gradle makes a debug build
			if(isDebug())
				setenv("ANDROID_GRADLE_TASK", "assembleDebug");

			// external java code
			javaPaths.push(Path.join([SOURCE_DIR, 'funkin/mobile/external/android/java']));

			// go my keystore!! (i don't care about securing this)
			// this isn't going on the app store anytime soon
			if(isRelease()) {
				keystore = new Keystore();
				keystore.path = 'key.keystore';
				keystore.alias = 'Garfield';
				keystore.password = 'GarfieldLovesLasagna';
			}
			Reflect.setField(config.get('android.manifest'), 'xmlns:tools', 'http://schemas.android.com/tools');
			final permissionsConfig:Array<String> = [
				'<uses-permission android:name="android.permission.MANAGE_MEDIA" tools:node="remove" tools:ignore="ScopedStorage" />',
				'<uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE" tools:node="remove" tools:ignore="ScopedStorage" />',
				'<uses-permission android:name="android.permission.ACCESS_MEDIA_LOCATION" tools:node="remove" tools:ignore="ScopedStorage"/>',
				'<uses-permission android:name="android.permission.READ_MEDIA_IMAGES" tools:node="remove" />',
				'<uses-permission android:name="android.permission.READ_MEDIA_AUDIO" tools:node="remove" />',
				'<uses-permission android:name="android.permission.READ_MEDIA_VIDEO" tools:node="remove" />',
				'<uses-permission android:name="android.permission.VIBRATE" tools:node="remove" />',
				'<uses-permission android:name="android.permission.INTERNET" tools:node="remove" />',
				'<uses-permission android:name="android.permission.ACCESS_WIFI_STATE" tools:node="remove"/>',
				'<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" tools:node="remove" />',
				'<uses-permission android:name="android.permission.CAPTURE_AUDIO_OUTPUT" tools:node="remove" />',
				'<uses-permission android:name="android.permission.READ_PHONE_STATE" tools:node="remove" />',
				'<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" tools:node="remove" />',
				'<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" tools:node="remove" android:maxSdkVersion="29"/>'
			];
			final xmlChildren:Null<Array<String>> = config.get('android.manifest').xmlChildren;
			if (xmlChildren != null)
				config.get('android.manifest').xmlChildren = xmlChildren.concat(permissionsConfig);
			else
				config.get('android.manifest').xmlChildren = permissionsConfig;

			config.set("android.minimum-sdk-version", ANDROID_MINIMUM_SDK_VERSION);
			config.set("android.target-sdk-version", ANDROID_TARGET_SDK_VERSION);

			if (isBundle())
				config.set("android.gradle-project-directory", "bin-bundle");
			
			architectures.push(Architecture.X86);
			architectures.push(Architecture.X64);

			final modsFolderProvider = [
				'<provider android:authorities="${meta.packageName}.docprovider" android:name="funkin.provider.DataFolderProvider" android:grantUriPermissions="true" android:exported="true" android:permission="android.permission.MANAGE_DOCUMENTS">',
				'  <intent-filter>',
				'    <action android:name="android.content.action.DOCUMENTS_PROVIDER" />',
				'  </intent-filter>',
				'</provider>'
			];
			Reflect.setField(config.get('android.application'), "android:requestLegacyExternalStorage", "true");
			final xmlChildren:Null<Array<String>> = config.get('android.application').xmlChildren;
			if (xmlChildren != null)
				config.get('android.application').xmlChildren = xmlChildren.concat(modsFolderProvider);
			else
				config.get('android.application').xmlChildren = modsFolderProvider;

			final extensions:Null<Array<String>> = config.getArrayString('android.extension');
			for (extension in ANDROID_EXTENSIONS) {
				if (extensions == null || extensions != null && extensions.indexOf(extension) == -1)
					config.push("android.extension", extension);
			}
		}
	}

	// [ helper funcs ] //

	public function isASTCExcluded(filePath:String):Bool {
		for (exclusion in astcExcludes) {
			if (exclusion.endsWith("/*")) {
				var normalizedFilePath = Path.normalize(filePath);
				var normalizedExclusion = Path.normalize(exclusion.substr(0, exclusion.length - 2));

				if (normalizedFilePath.startsWith(normalizedExclusion))
					return true;
			}
			else if (exclusion.endsWith("/"))
			{
				var normalizedExclusion = Path.normalize(exclusion);
				var fileDirectory = Path.directory(Path.normalize(filePath));

				if (fileDirectory == normalizedExclusion)
					return true;
			}
			else
			{
				if (filePath == exclusion)
					return true;
			}
		}
		return false;
	}

	/**
	 * Add an asset to the game build.
	 * @param path The path the asset is located at.
	 * @param rename The path the asset should be placed.
	 * @param library The asset library to add the asset to. `null` = "default"
	 * @param embed Whether to embed the asset in the executable.
	 * @param padName The name of the Play Assets Delivery that this asset will be added to. (Android only)
	 */
	public function addAsset(path:String, ?rename:String, ?library:String, ?embed:Bool = false, ?padName:String):Void {
		// TODO: get astc asset compression working again...at some point
		// i can't be bothered to make OpenFL be able to locate the asset
		// i swear i had it working at one point too, no clue what happened
		// this code will stay as a remnant
		//
		// if (Path.extension(path) == 'png' && isMobile() && !isDebug()) {
		// 	final astcPath:String = "astc-textures/" + path.substr(0, path.length - 3) + "astc";
		// 	if (!isASTCExcluded(path) && FileSystem.exists(astcPath)) {
		// 		path = astcPath;

		// 		if (rename != null)
		// 			rename = rename.substr(0, rename.length - 3) + "astc";
		// 	}
		// }
		var asset = new Asset(path, rename, null, embed, true);
		asset.library = library ?? "default";

		if (padName != null && isBundle())
			asset.deliveryPackName = padName;

		assets.push(asset);
	}

	/**
	 * Add an entire path of assets to the game build.
	 * @param path The path the assets are located at.
	 * @param rename The path the assets should be placed.
	 * @param library The asset library to add the assets to. `null` = "default"
	 * @param include An optional array to include specific asset names.
	 * @param exclude An optional array to exclude specific asset names.
	 * @param embed Whether to embed the assets in the executable.
	 * @param padName The name of the Play Assets Delivery that this asset path will be added to. (Android only)
	 */
	public function addAssetPath(path:String, ?rename:String, ?library:String, ?include:Array<String>, ?exclude:Array<String>, ?embed:Bool = false,
			?padName:String):Void {
		// Argument parsing.
		if (path == "")
			return;

		if (include == null)
			include = [];

		if (exclude == null)
			exclude = [];

		var targetPath = rename ?? path;
		if (targetPath != "")
			targetPath += "/";

		// Validate path.
		if (!sys.FileSystem.exists(path)) {
			error('Could not find asset path "${path}".');
		} else if (!sys.FileSystem.isDirectory(path)) {
			error('Could not parse asset path "${path}", expected a directory.');
		} else {
			// info('  Found asset path "${path}".');
		}

		for (file in sys.FileSystem.readDirectory(path)) {
			if (sys.FileSystem.isDirectory('${path}/${file}')) {
				// Attempt to recursively add all assets in the directory.
				if (filter(file, ["*"], exclude)) {
					addAssetPath('${path}/${file}', '${targetPath}${file}', library, include, exclude, embed, padName);
				}
			} else {
				if (filter(file, include, exclude)) {
					addAsset('${path}/${file}', '${targetPath}${file}', library, embed, padName);
				}
			}
		}
	}

	/**
	 * Add an asset library to the game build.
	 * @param name The name of the library.
	 * @param embed
	 * @param preload
	 */
	public function addAssetLibrary(name:String, embed:Bool = false, preload:Bool = false):Void {
		// sourcePath, name, type, embed, preload, generate, prefix
		var sourcePath = '';
		libraries.push(new Library(sourcePath, name, null, embed, preload, false, ""));
	}

	public function isWeb():Bool {
		return platformType == PlatformType.WEB;
	}

	public function isMobile():Bool {
		return platformType == PlatformType.MOBILE;
	}

	public function isDesktop():Bool {
		return platformType == PlatformType.DESKTOP;
	}

	public function isConsole():Bool {
		return platformType == PlatformType.CONSOLE;
	}

	public function is32Bit():Bool {
		return architectures.contains(Architecture.X86);
	}

	public function is64Bit():Bool {
		return architectures.contains(Architecture.X64);
	}

	public function isWindows():Bool {
		return target == Platform.WINDOWS;
	}

	public function isMac():Bool {
		return target == Platform.MAC;
	}

	public function isLinux():Bool {
		return target == Platform.LINUX;
	}

	public function isAndroid():Bool {
		return target == Platform.ANDROID;
	}

	public function isIOS():Bool {
		return target == Platform.IOS;
	}

	public function isIOSSimulator():Bool {
		return target == Platform.IOS && targetFlags.exists("simulator");
	}

	public function isHashLink():Bool {
		return targetFlags.exists("hl");
	}

	public function isNeko():Bool {
		return targetFlags.exists("neko");
	}

	public function isJava():Bool {
		return targetFlags.exists("java");
	}

	public function isNodeJS():Bool {
		return targetFlags.exists("nodejs");
	}

	public function isCSharp():Bool {
		return targetFlags.exists("cs");
	}

	public function isDisplay():Bool {
		return command == "display";
	}

	public function isCPP():Bool {
		return !isHashLink() && !isNeko() && !isJava() && !isNodeJS() && !isCSharp() && !isDisplay();
	}

	public function isDebug():Bool {
		return debug;
	}

	public function isRelease():Bool {
		return !isDebug();
	}

	public function isBundle():Bool {
		return targetFlags.exists("bundle") && isAndroid();
	}

	public function getHaxedef(name:String):Null<Dynamic> {
		return haxedefs.get(name);
	}

	public function setHaxedef(name:String, ?value:String):Void {
		if (value == null)
			value = "";
		haxedefs.set(name, value);
	}

	public function unsetHaxedef(name:String):Void {
		haxedefs.remove(name);
	}

	public function setDefine(name:String, ?value:Null<String>):Void {
		haxedefs.set(name, value ?? "1");
		defines.set(name, value ?? "1");
	}

	public function getDefine(name:String):Null<Dynamic> {
		return defines.get(name);
	}

	public function hasDefine(name:String):Bool {
		return defines.exists(name);
	}

	public function isDefined(name:String):Bool {
		return defines.get(name) == 'true' || defines.get(name) == '1';
	}

	/**
	 * Add a library to the list of dependencies for the project.
	 * @param name The name of the library to add.
	 * @param version The version of the library to add. Optional.
	 */
	public function addHaxelib(name:String, version:String = ""):Void {
		haxelibs.push(new Haxelib(name, version));
	}

	/**
	 * Add a `haxeflag` to the project.
	 */
	public function addHaxeFlag(value:String):Void {
		haxeflags.push(value);
	}

	/**
	 * Call a Haxe build macro.
	 */
	public function addHaxeMacro(value:String):Void {
		addHaxeFlag('--macro ${value}');
	}

	/**
	 * Add an icon to the project.
	 * @param icon The path to the icon.
	 * @param size The size of the icon. Optional.
	 */
	public function addIcon(icon:String, ?size:Int):Void {
		icons.push(new Icon(icon, size));
	}

	/**
	 * Display an error message. This should stop the build process.
	 */
	public function error(message:String):Void {
		Log.error('${message}');
	}

	/**
	 * Display an info message. This should not interfere with the build process.
	 */
	public function info(message:String):Void {
		if (command != "display")
			Log.info('[INFO] ${message}');
	}
}
