ANDROID_HOME=/mnt/BEB05C81B05C41D7/AndroidSDK/
ANDROID_NDK=/opt/android-ndk
ANDROID_NDK_HOME=/opt/android-ndk
ANDROID_NDK_ROOT=/opt/android-ndk
ANDROID_SDK_ROOT=/mnt/BEB05C81B05C41D7/AndroidSDK/
BASH=/bin/bash
BASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:globasciiranges:globskipdots:interactive_comments:patsub_replacement:progcomp:promptvars:sourcepath
BASHRCSOURCED=Y
BASH_ALIASES=()
BASH_ARGC=([0]="0")
BASH_ARGV=()
BASH_CMDS=()
BASH_COMPLETION_VERSINFO=([0]="2" [1]="16" [2]="0")
BASH_LINENO=()
BASH_LOADABLES_PATH=/usr/local/lib/bash:/usr/lib/bash:/opt/local/lib/bash:/usr/pkg/lib/bash:/opt/pkg/lib/bash:.
BASH_SOURCE=()
BASH_VERSINFO=([0]="5" [1]="3" [2]="3" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
BASH_VERSION='5.3.3(1)-release'
BROWSER=firefox
COLORFGBG='15;0'
COLORTERM=truecolor
COLUMNS=148
COMP_FILEDIR_FALLBACK=BASH_COMPLETION_FILEDIR_FALLBACK
COMP_KNOWN_HOSTS_WITH_AVAHI=BASH_COMPLETION_KNOWN_HOSTS_WITH_AVAHI
COMP_KNOWN_HOSTS_WITH_HOSTFILE=BASH_COMPLETION_KNOWN_HOSTS_WITH_HOSTFILE
DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus
DEBUGINFOD_URLS='https://debuginfod.archlinux.org '
DESKTOP_SESSION=plasmax11
DEVKITARM=/opt/devkitpro/devkitARM
DEVKITPPC=/opt/devkitpro/devkitPPC
DEVKITPRO=/opt/devkitpro
DIRSTACK=()
DISPLAY=:0
EDITOR=nano
EUID=1000
GLUSTER_BARRIER_OPTIONS=$'\n        {enable},\n        {disable}\n'
GLUSTER_COMMAND_TREE=$'\n{gluster [\n        \n        {volume [\n                {add-brick\n                        {__VOLNAME}\n                },\n                {barrier\n                        {__VOLNAME\n                                [ \n        {enable},\n        {disable}\n ]\n                        }\n                },\n                {clear-locks\n                        {__VOLNAME}\n                },\n                {create},\n                {delete\n                        {__VOLNAME}\n                },\n                {geo-replication\n                        [ \n        {status},\n        {__VOLNAME [\n                {status},\n                {__SECONDARYURL [\n                        {create [\n                                {push-pem\n                                        {force}\n                                },\n                                {force}\n                                ]\n                        },\n                        {start {force} },\n                        {status {detail} },\n                        {config},\n                        {pause {force} },\n                        {resume {force} },\n                        {stop {force} },\n                        {delete {force} }\n                            ]\n                }\n                   ]\n        }\n ]\n                },\n                {heal\n                        {__VOLNAME}\n                },\n                {help},\n                {info\n                        {__VOLNAME}\n                },\n                {list},\n                {log\n                        {__VOLNAME}\n                },\n                {profile\n                        {__VOLNAME\n                                [ \n        {start},\n        {info [\n                {peek},\n                {incremental\n                        {peek}\n                },\n                {cumulative},\n                {clear},\n              ]\n        },\n        {stop}\n ]\n                        }\n                },\n                {quota\n                        {__VOLNAME\n                                [ \n        {enable},\n        {disable},\n        {list},\n        {remove},\n        {default-soft-limit},\n        {limit-usage},\n        {alert-time},\n        {soft-timeout},\n        {hard-timeout}\n ]\n                        }\n                },\n                {rebalance\n                        {__VOLNAME}\n                },\n                {remove-brick\n                        {__VOLNAME}\n                },\n                {replace-brick\n                        {__VOLNAME}\n                },\n                {reset\n                        {__VOLNAME\n                                [  ]\n                        }\n                },\n                {set\n                        {__VOLNAME\n                                [  ]\n                        }\n                },\n                {start\n                        {__VOLNAME\n                                {force}\n                        }\n                },\n                {statedump\n                        {__VOLNAME}\n                },\n                {status\n                        {__VOLNAME}\n                },\n                {stop\n                        {__VOLNAME\n                                {force}\n                        }\n                },\n                {sync\n                        {__HOSTNAME}\n                },\n                {top\n                        {__VOLNAME\n                                [ \n        {open\n                [ \n        {nfs},\n        {brick},\n        {list-cnt}\n ]\n        },\n        {read\n                [ \n        {nfs},\n        {brick},\n        {list-cnt}\n ]\n        },\n        {write\n                [ \n        {nfs},\n        {brick},\n        {list-cnt}\n ]\n        },\n        {opendir\n                [ \n        {nfs},\n        {brick},\n        {list-cnt}\n ]\n        },\n        {readdir\n                [ \n        {nfs},\n        {brick},\n        {list-cnt}\n ]\n        },\n        {clear\n                [ \n        {nfs},\n        {brick},\n        {list-cnt}\n ]\n        },\n        {read-perf\n                [ \n        {bs\n                {__SIZE\n                        {count}\n                }\n        },\n        {brick},\n        {list-cnt}\n ]\n        },\n        {write-perf\n                [ \n        {bs\n                {__SIZE\n                        {count}\n                }\n        },\n        {brick},\n        {list-cnt}\n ]\n        }\n ]\n                        }\n                }\n                ]\n        }\n ,\n        {peer [\n              {probe\n                      {__HOSTNAME}\n              },\n              {detach\n                      {__HOSTNAME\n                                {force}\n                      }\n              },\n              {status}\n              ]\n        },\n        {pool\n                {list}\n        },\n        {help}\n        ]\n}'
GLUSTER_FINAL_LIST=
GLUSTER_GEO_REPLICATION_OPTIONS=$'\n        {status},\n        {__VOLNAME [\n                {status},\n                {__SECONDARYURL [\n                        {create [\n                                {push-pem\n                                        {force}\n                                },\n                                {force}\n                                ]\n                        },\n                        {start {force} },\n                        {status {detail} },\n                        {config},\n                        {pause {force} },\n                        {resume {force} },\n                        {stop {force} },\n                        {delete {force} }\n                            ]\n                }\n                   ]\n        }\n'
GLUSTER_GEO_REPLICATION_SUBOPTIONS=$'\n'
GLUSTER_LIST=
GLUSTER_PROFILE_OPTIONS=$'\n        {start},\n        {info [\n                {peek},\n                {incremental\n                        {peek}\n                },\n                {cumulative},\n                {clear},\n              ]\n        },\n        {stop}\n'
GLUSTER_QUOTA_OPTIONS=$'\n        {enable},\n        {disable},\n        {list},\n        {remove},\n        {default-soft-limit},\n        {limit-usage},\n        {alert-time},\n        {soft-timeout},\n        {hard-timeout}\n'
GLUSTER_TOP=0
GLUSTER_TOP_OPTIONS=$'\n        {open\n                [ \n        {nfs},\n        {brick},\n        {list-cnt}\n ]\n        },\n        {read\n                [ \n        {nfs},\n        {brick},\n        {list-cnt}\n ]\n        },\n        {write\n                [ \n        {nfs},\n        {brick},\n        {list-cnt}\n ]\n        },\n        {opendir\n                [ \n        {nfs},\n        {brick},\n        {list-cnt}\n ]\n        },\n        {readdir\n                [ \n        {nfs},\n        {brick},\n        {list-cnt}\n ]\n        },\n        {clear\n                [ \n        {nfs},\n        {brick},\n        {list-cnt}\n ]\n        },\n        {read-perf\n                [ \n        {bs\n                {__SIZE\n                        {count}\n                }\n        },\n        {brick},\n        {list-cnt}\n ]\n        },\n        {write-perf\n                [ \n        {bs\n                {__SIZE\n                        {count}\n                }\n        },\n        {brick},\n        {list-cnt}\n ]\n        }\n'
GLUSTER_TOP_SUBOPTIONS1=$'\n        {nfs},\n        {brick},\n        {list-cnt}\n'
GLUSTER_TOP_SUBOPTIONS2=$'\n        {bs\n                {__SIZE\n                        {count}\n                }\n        },\n        {brick},\n        {list-cnt}\n'
GLUSTER_VOLUME_OPTIONS=$'\n        {volume [\n                {add-brick\n                        {__VOLNAME}\n                },\n                {barrier\n                        {__VOLNAME\n                                [ \n        {enable},\n        {disable}\n ]\n                        }\n                },\n                {clear-locks\n                        {__VOLNAME}\n                },\n                {create},\n                {delete\n                        {__VOLNAME}\n                },\n                {geo-replication\n                        [ \n        {status},\n        {__VOLNAME [\n                {status},\n                {__SECONDARYURL [\n                        {create [\n                                {push-pem\n                                        {force}\n                                },\n                                {force}\n                                ]\n                        },\n                        {start {force} },\n                        {status {detail} },\n                        {config},\n                        {pause {force} },\n                        {resume {force} },\n                        {stop {force} },\n                        {delete {force} }\n                            ]\n                }\n                   ]\n        }\n ]\n                },\n                {heal\n                        {__VOLNAME}\n                },\n                {help},\n                {info\n                        {__VOLNAME}\n                },\n                {list},\n                {log\n                        {__VOLNAME}\n                },\n                {profile\n                        {__VOLNAME\n                                [ \n        {start},\n        {info [\n                {peek},\n                {incremental\n                        {peek}\n                },\n                {cumulative},\n                {clear},\n              ]\n        },\n        {stop}\n ]\n                        }\n                },\n                {quota\n                        {__VOLNAME\n                                [ \n        {enable},\n        {disable},\n        {list},\n        {remove},\n        {default-soft-limit},\n        {limit-usage},\n        {alert-time},\n        {soft-timeout},\n        {hard-timeout}\n ]\n                        }\n                },\n                {rebalance\n                        {__VOLNAME}\n                },\n                {remove-brick\n                        {__VOLNAME}\n                },\n                {replace-brick\n                        {__VOLNAME}\n                },\n                {reset\n                        {__VOLNAME\n                                [  ]\n                        }\n                },\n                {set\n                        {__VOLNAME\n                                [  ]\n                        }\n                },\n                {start\n                        {__VOLNAME\n                                {force}\n                        }\n                },\n                {statedump\n                        {__VOLNAME}\n                },\n                {status\n                        {__VOLNAME}\n                },\n                {stop\n                        {__VOLNAME\n                                {force}\n                        }\n                },\n                {sync\n                        {__HOSTNAME}\n                },\n                {top\n                        {__VOLNAME\n                                [ \n        {open\n                [ \n        {nfs},\n        {brick},\n        {list-cnt}\n ]\n        },\n        {read\n                [ \n        {nfs},\n        {brick},\n        {list-cnt}\n ]\n        },\n        {write\n                [ \n        {nfs},\n        {brick},\n        {list-cnt}\n ]\n        },\n        {opendir\n                [ \n        {nfs},\n        {brick},\n        {list-cnt}\n ]\n        },\n        {readdir\n                [ \n        {nfs},\n        {brick},\n        {list-cnt}\n ]\n        },\n        {clear\n                [ \n        {nfs},\n        {brick},\n        {list-cnt}\n ]\n        },\n        {read-perf\n                [ \n        {bs\n                {__SIZE\n                        {count}\n                }\n        },\n        {brick},\n        {list-cnt}\n ]\n        },\n        {write-perf\n                [ \n        {bs\n                {__SIZE\n                        {count}\n                }\n        },\n        {brick},\n        {list-cnt}\n ]\n        }\n ]\n                        }\n                }\n                ]\n        }\n'
GROUPS=()
GTK2_RC_FILES=/etc/gtk-2.0/gtkrc:/home/swordcube/.gtkrc-2.0:/home/swordcube/.config/gtkrc-2.0
GTK3_MODULES=xapp-gtk3-module
GTK_MODULES=canberra-gtk-module
GTK_RC_FILES=/etc/gtk/gtkrc:/home/swordcube/.gtkrc:/home/swordcube/.config/gtkrc
HAXE_STD_PATH=/usr/share/haxe/std
HISTFILE=/home/swordcube/.bash_history
HISTFILESIZE=500
HISTSIZE=500
HOME=/home/swordcube
HOSTNAME=cubical-pc
HOSTTYPE=x86_64
ICEAUTHORITY=/run/user/1000/iceauth_KUqCgL
IFS=$' \t\n'
INVOCATION_ID=2cf04e98cdcf41f2adbd9a4070e5d8b4
JOURNAL_STREAM=9:13303
KDE_APPLICATIONS_AS_SCOPE=1
KDE_FULL_SESSION=true
KDE_SESSION_UID=1000
KDE_SESSION_VERSION=6
KONSOLE_DBUS_SERVICE=:1.131
KONSOLE_DBUS_SESSION=/Sessions/1
KONSOLE_DBUS_WINDOW=/Windows/1
KONSOLE_VERSION=250403
LANG=en_US.UTF-8
LANGUAGE=
LC_ADDRESS=en_US.UTF-8
LC_IDENTIFICATION=en_US.UTF-8
LC_MEASUREMENT=en_US.UTF-8
LC_MONETARY=en_US.UTF-8
LC_NAME=en_US.UTF-8
LC_NUMERIC=en_US.UTF-8
LC_PAPER=en_US.UTF-8
LC_TELEPHONE=en_US.UTF-8
LC_TIME=en_US.UTF-8
LINES=34
LOGNAME=swordcube
MACHTYPE=x86_64-pc-linux-gnu
MAIL=/var/spool/mail/swordcube
MAILCHECK=60
MANAGERPID=1124
MEMORY_PRESSURE_WATCH=/sys/fs/cgroup/user.slice/user-1000.slice/user@1000.service/session.slice/plasma-plasmashell.service/memory.pressure
MEMORY_PRESSURE_WRITE=c29tZSAyMDAwMDAgMjAwMDAwMAA=
MOTD_SHOWN=pam
OPTERR=1
OPTIND=1
OSTYPE=linux-gnu
PAM_KWALLET5_LOGIN=/run/user/1000/kwallet5.socket
PATH=/opt/devkitpro/tools/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/opt/android-ndk:/opt/android-sdk/cmdline-tools/latest/bin:/opt/android-sdk/platform-tools:/home/swordcube/.local/share/flatpak/exports/bin:/var/lib/flatpak/exports/bin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl:/mnt/BEB05C81B05C41D7/AndroidSDK//tools:/mnt/BEB05C81B05C41D7/AndroidSDK//platform-tools:/mnt/BEB05C81B05C41D7/AndroidSDK//ndk
PIPESTATUS=([0]="0")
PPID=3182
PROFILEHOME=
PROMPT_COMMAND=([0]="printf \"\\033]0;%s@%s:%s\\007\" \"\${USER}\" \"\${HOSTNAME%%.*}\" \"\${PWD/#\$HOME/\\~}\"")
PS1='C:${PWD//\//\\\\}> '
PS2='> '
PS4='+ '
PWD='/mnt/B64005D340059AEF/Refresh/Programming/Haxe/- HaxeFlixel/friday again garfie baby'
QML_DISABLE_DISTANCEFIELD=1
QT_WAYLAND_RECONNECT=1
SESSION_MANAGER=local/cubical-pc:@/tmp/.ICE-unix/1297,unix/cubical-pc:/tmp/.ICE-unix/1297
SHELL=/bin/bash
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
SHELL_MOMMYS_COLOR='\e[38;5;117m'
SHELL_MOMMYS_LITTLE=goober
SHELL_MOMMYS_PRONOUNS=his
SHELL_MOMMYS_ROLES=jay
SHELL_SESSION_ID=0d2dc67831944485b055f0cbcec888fb
SHLVL=1
SYSTEMD_EXEC_PID=1341
TERM=xterm-256color
UID=1000
USER=swordcube
WINDOWID=88080398
XAUTHORITY=/tmp/xauth_oYoZnp
XDG_CONFIG_DIRS=/home/swordcube/.config/kdedefaults:/etc/xdg
XDG_CURRENT_DESKTOP=KDE
XDG_DATA_DIRS=/home/swordcube/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share:/usr/local/share:/usr/share
XDG_MENU_PREFIX=plasma-
XDG_RUNTIME_DIR=/run/user/1000
XDG_SEAT=seat0
XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0
XDG_SESSION_CLASS=user
XDG_SESSION_DESKTOP=KDE
XDG_SESSION_ID=2
XDG_SESSION_PATH=/org/freedesktop/DisplayManager/Session1
XDG_SESSION_TYPE=x11
XDG_VTNR=2
_=set
_backup_glob='@(#*#|*@(~|.@(bak|orig|rej|swp|@(dpkg|ucf)-*|rpm@(orig|new|save))))'
_comp__base_directory=/usr/share/bash-completion
_comp_backup_glob='@(#*#|*@(~|.@(bak|orig|rej|swp|@(dpkg|ucf)-*|rpm@(orig|new|save))))'
_comp_dequote__regex_safe_word='^([^\'\''"$`;&|<>()!]|\\.|'\''[^'\'']*'\''|\$?"([^\"$`!]|\$([_a-zA-Z][_a-zA-Z0-9]*|[-*@#?$!0-9_])|\$\{[!#]?([_a-zA-Z][_a-zA-Z0-9]*(\[([0-9]+|[*@])\])?|[-*@#?$!0-9_])\}|\\.)*"|\$'\''([^\'\'']|\\.)*'\''|\$([_a-zA-Z][_a-zA-Z0-9]*|[-*@#?$!0-9_])|\$\{[!#]?([_a-zA-Z][_a-zA-Z0-9]*(\[([0-9]+|[*@])\])?|[-*@#?$!0-9_])\})*$'
_comp_xspecs=([tex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [freeamp]="!*.@(mp3|ogg|pls|m3u)" [gqmpeg]="!*.@(mp3|ogg|pls|m3u)" [texi2html]="!*.texi*" [hbpp]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [lowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm|pdf)" [rpm2cpio]="!*.[rs]pm" [localc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [hbrun]="!*.[Hh][Rr][Bb]" [vi]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [latex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [view]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [madplay]="!*.mp3" [compress]="*.Z" [pdfjadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [pbunzip2]="!*.?(t)bz?(2)" [lrunzip]="!*.lrz" [gunzip]="!*.@(Z|[gGd]z|t[ag]z)" [oowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm|pdf)" [epiphany]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [acroread]="!*.[pf]df" [znew]="*.Z" [kwrite]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [xemacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [gview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [lzfgrep]="!*.@(tlz|lzma)" [lzless]="!*.@(tlz|lzma)" [cdiff]="!*.@(dif?(f)|?(d)patch)?(.@([gx]z|bz2|lzma))" [zipinfo]="!*.@(zip|[aegjkswx]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|?(o)xps|epub|cbz|apk|aab|ipa|do[ct][xm]|p[op]t[mx]|xl[st][xm]|pyz|vsix|whl|[Ff][Cc][Ss]td)" [pdflatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [portecle]="!@(*.@(ks|jks|jceks|p12|pfx|bks|ubr|gkr|cer|crt|cert|p7b|pkipath|pem|p10|csr|crl)|cacerts)" [modplugplay]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|oct|okt?(a)|p[st]m|s[3t]m|ult|umx|wav|xm)" [lokalize]="!*.po" [lbzcat]="!*.?(t)bz?(2)" [qiv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|svg)" [totem]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|opus|OPUS|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [ps2pdfwr]="!*.@(?(e)ps|pdf)" [dvitype]="!*.dvi" [unpigz]="!*.@(Z|[gGdz]z|t[ag]z)" [mozilla]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [pdfunite]="!*.pdf" [gpdf]="!*.[pf]df" [texi2dvi]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [bunzip2]="!*.?(t)bz?(2)" [zathura]="!*.@(cb[rz7t]|djv?(u)|?(e)ps|pdf)" [kaffeine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|opus|OPUS|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [mpg123]="!*.mp3" [lzegrep]="!*.@(tlz|lzma)" [xv]="!*.@(gif|jp?(e)g?(2)|j2[ck]|jp[2f]|tif?(f)|png|p[bgpn]m|webp|bmp|x[bp]m|rle|rgb|pcx|fits|pm|?(e)ps)" [xdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [xfig]="!*.fig" [xpdf]="!*.[pf]df" [oobase]="!*.odb" [xelatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [gharbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [bzcat]="!*.?(t)bz?(2)" [dragon]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|opus|OPUS|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [xanim]="!*.@(mpg|mpeg|avi|mov|qt)" [lualatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [rgview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [rvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [xetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [lomath]="!*.@(sxm|smf|mml|odf)" [zcat]="!*.@(Z|[gGd]z|t[ag]z)" [lynx]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [uncompress]="!*.Z" [xzcat]="!*.@(?(t)xz|tlz|lzma)" [vim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [loimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [dvipdf]="!*.dvi" [mpg321]="!*.mp3" [jadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [lobase]="!*.odb" [epdfview]="!*.pdf" [ps2pdf14]="!*.@(?(e)ps|pdf)" [ps2pdf13]="!*.@(?(e)ps|pdf)" [ps2pdf12]="!*.@(?(e)ps|pdf)" [poedit]="!*.po" [luatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [kbabel]="!*.po" [bzme]="!*.@(zip|z|gz|tgz)" [dviselect]="!*.dvi" [realplay]="!*.@(rm?(j)|ra?(m)|smi?(l))" [kdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [elinks]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [kghostview]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [gtranslator]="!*.po" [unzip]="!*.@(zip|[aegjkswx]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|?(o)xps|epub|cbz|apk|aab|ipa|do[ct][xm]|p[op]t[mx]|xl[st][xm]|pyz|vsix|whl|[Ff][Cc][Ss]td)" [ggv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [oomath]="!*.@(sxm|smf|mml|odf)" [dvipdfmx]="!*.dvi" [makeinfo]="!*.texi*" [okular]="!*.@(okular|@(?(e|x)ps|?(E|X)PS|[pf]df|[PF]DF|dvi|DVI|cb[rz]|CB[RZ]|djv?(u)|DJV?(U)|dvi|DVI|gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx|GIF|JP?(E)G|MIFF|TIF?(F)|PN[GM]|P[BGP]M|BMP|XPM|ICO|XWD|TGA|PCX|epub|EPUB|odt|ODT|fb?(2)|FB?(2)|mobi|MOBI|g3|G3|chm|CHM|md|markdown)?(.?(gz|GZ|bz2|BZ2|xz|XZ)))" [cacaxine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [sxemacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [aviplay]="!*.@(avi|asf|wmv)" [rgvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dvipdfm]="!*.dvi" [ly2dvi]="!*.ly" [oodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [kpdf]="!*.@(?(e)ps|pdf)" [bibtex]="!*.aux" [netscape]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [emacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [rview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [galeon]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [dillo]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [fbxine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [oocalc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [harbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [lodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [dvips]="!*.dvi" [ps2pdf]="!*.@(?(e)ps|pdf)" [kate]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [kid3-qt]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [pdftex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [gvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [timidity]="!*.@(mid?(i)|rmi|rcp|[gr]36|g18|mod|xm|it|x3m|s[3t]m|kar)" [ogg123]="!*.@(og[ag]|m3u|flac|spx)" [lzgrep]="!*.@(tlz|lzma)" [ee]="!*.@(gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx)" [unlzma]="!*.@(tlz|lzma)" [lbunzip2]="!*.?(t)bz?(2)" [ooimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [xine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [amaya]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [kid3]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [lilypond]="!*.ly" [modplug123]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|oct|okt?(a)|p[st]m|s[3t]m|ult|umx|wav|xm)" [pbzcat]="!*.?(t)bz?(2)" [unxz]="!*.@(?(t)xz|tlz|lzma)" [playmidi]="!*.@(mid?(i)|cmf)" [lzcat]="!*.@(tlz|lzma)" [slitex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [aaxine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [advi]="!*.dvi" [lzmore]="!*.@(tlz|lzma)" )
func_return=
__HOSTNAME () 
{ 
    local zero=0;
    local ret=0;
    local cur_word="$2";
    if [ "$1" == "X" ]; then
        return;
    else
        if [ "$1" == "match" ]; then
            return 0;
        else
            if [ "$1" == "complete" ]; then
                func_return=`echo $(compgen -A hostname -- $cur_word)`;
            fi;
        fi;
    fi;
    return 0
}
__SECONDARYURL () 
{ 
    func_return="SECONDARYURL";
    return 0
}
__SIZE () 
{ 
    func_return="SIZE";
    return 0
}
__VOLNAME () 
{ 
    local zero=0;
    local ret=0;
    local cur_word="$2";
    local list="";
    if [ "X$1" == "X" ]; then
        return;
    else
        if [ "$1" == "match" ]; then
            return 0;
        else
            if [ "$1" == "complete" ]; then
                if ! pidof glusterd > /dev/null 2>&1; then
                    list='';
                else
                    list=`gluster volume list 2> /dev/null`;
                fi;
            else
                return 0;
            fi;
        fi;
    fi;
    func_return=`echo $(compgen -W "$list" -- $cur_word)`;
    return 0
}
__expand_tilde_by_ref () 
{ 
    [[ -n ${1+set} ]] || return 0;
    [[ $1 == REPLY ]] || local REPLY;
    _comp_expand_tilde "${!1-}";
    [[ $1 == REPLY ]] || printf -v "$1" "$REPLY"
}
__load_completion () 
{ 
    _comp_load "$@"
}
__ltrim_colon_completions () 
{ 
    _comp_ltrim_colon_completions "$@"
}
__parse_options () 
{ 
    local -a _options=();
    _comp_compgen_help__parse "$1";
    printf '%s\n' "${_options[@]}"
}
_allowed_groups () 
{ 
    _comp_compgen -c "${1:-$cur}" allowed_groups
}
_allowed_users () 
{ 
    _comp_compgen -c "${1:-$cur}" allowed_users
}
_available_interfaces () 
{ 
    _comp_compgen_available_interfaces "$@"
}
_bashcomp_try_faketty () 
{ 
    _comp_try_faketty "$@"
}
_cd () 
{ 
    declare -F _comp_cmd_cd &> /dev/null || __load_completion cd;
    _comp_cmd_cd "$@"
}
_cd_devices () 
{ 
    _comp_compgen -a cd_devices
}
_command () 
{ 
    _comp_command "$@"
}
_command_offset () 
{ 
    local words;
    unset -v words;
    _comp_command_offset "$@"
}
_comp__find_original_word () 
{ 
    REPLY=$1;
    [[ -v cword && -v words ]] || return 0;
    local reassembled_offset=$1 i=0 j;
    for ((j = 0; j < reassembled_offset; j++))
    do
        local word=${words[j]};
        while [[ -n $word && i -lt ${#COMP_WORDS[@]} && $word == *"${COMP_WORDS[i]}"* ]]; do
            word=${word#*"${COMP_WORDS[i++]}"};
        done;
    done;
    REPLY=$i
}
_comp__get_cword_at_cursor () 
{ 
    local cword words=();
    _comp__reassemble_words "$1" words cword;
    local i cur="" index=$COMP_POINT lead=${COMP_LINE:0:COMP_POINT};
    if [[ $index -gt 0 && ( -n $lead && -n ${lead//[[:space:]]/} ) ]]; then
        cur=$COMP_LINE;
        for ((i = 0; i <= cword; ++i))
        do
            while [[ ${#cur} -ge ${#words[i]} && ${cur:0:${#words[i]}} != "${words[i]-}" ]]; do
                cur=${cur:1};
                ((index > 0)) && ((index--));
            done;
            if ((i < cword)); then
                local old_size=${#cur};
                cur=${cur#"${words[i]}"};
                local new_size=${#cur};
                ((index -= old_size - new_size));
            fi;
        done;
        [[ -n $cur && ! -n ${cur//[[:space:]]/} ]] && cur=;
        ((index < 0)) && index=0;
    fi;
    local IFS=' 	
';
    local "$2" "$3" "$4" && _comp_upvars -a"${#words[@]}" "$2" ${words[@]+"${words[@]}"} -v "$3" "$cword" -v "$4" "${cur:0:index}"
}
_comp__included_ssh_config_files () 
{ 
    (($# < 1)) && echo "bash_completion: $FUNCNAME: missing mandatory argument CONFIG" 1>&2;
    local configfile i files f REPLY;
    configfile=$1;
    local relative_include_base;
    if [[ $configfile == /etc/ssh* ]]; then
        relative_include_base="/etc/ssh";
    else
        relative_include_base="$HOME/.ssh";
    fi;
    local depth=1;
    local -a included;
    local -a include_files;
    included=("$configfile");
    local max_depth=16;
    while ((${#included[@]} > 0 && depth++ < max_depth)); do
        _comp_split include_files "$(command sed -ne 's/^[[:blank:]]*[Ii][Nn][Cc][Ll][Uu][Dd][Ee][[:blank:]]\(.*\)$/\1/p' "${included[@]}")" || return;
        included=();
        for i in "${include_files[@]}";
        do
            if [[ $i != [~/]* ]]; then
                i="${relative_include_base}/${i}";
            fi;
            _comp_expand_tilde "$i";
            if _comp_expand_glob files '$REPLY'; then
                for f in "${files[@]}";
                do
                    if [[ -r $f && ! -d $f ]]; then
                        config+=("$f");
                        included+=("$f");
                    fi;
                done;
            fi;
        done;
    done
}
_comp__reassemble_words () 
{ 
    local exclude="" i j line ref;
    if [[ -n $1 ]]; then
        exclude="[${1//[^$COMP_WORDBREAKS]/}]";
    fi;
    printf -v "$3" %s "$COMP_CWORD";
    if [[ -n $exclude ]]; then
        line=$COMP_LINE;
        for ((i = 0, j = 0; i < ${#COMP_WORDS[@]}; i++, j++))
        do
            while [[ $i -gt 0 && ${COMP_WORDS[i]} == +($exclude) ]]; do
                [[ $line != [[:blank:]]* ]] && ((j >= 2)) && ((j--));
                ref="$2[$j]";
                printf -v "$ref" %s "${!ref-}${COMP_WORDS[i]}";
                ((i == COMP_CWORD)) && printf -v "$3" %s "$j";
                line=${line#*"${COMP_WORDS[i]}"};
                if ((i < ${#COMP_WORDS[@]} - 1)); then
                    ((i++));
                else
                    break 2;
                fi;
                [[ $line == [[:blank:]]* ]] && ((j++));
            done;
            ref="$2[$j]";
            printf -v "$ref" %s "${!ref-}${COMP_WORDS[i]}";
            line=${line#*"${COMP_WORDS[i]}"};
            ((i == COMP_CWORD)) && printf -v "$3" %s "$j";
        done;
        ((i == COMP_CWORD)) && printf -v "$3" %s "$j";
    else
        for i in "${!COMP_WORDS[@]}";
        do
            printf -v "$2[i]" %s "${COMP_WORDS[i]}";
        done;
    fi
}
_comp__split_longopt () 
{ 
    if [[ $cur == --?*=* ]]; then
        prev=${cur%%?(\\)=*};
        cur=${cur#*=};
        return 0;
    fi;
    return 1
}
_comp_abspath () 
{ 
    REPLY=$1;
    [[ $REPLY == /* ]] || REPLY=$PWD/$REPLY;
    REPLY=${REPLY//+(\/)/\/};
    while true; do
        case $REPLY in 
            */./*)
                REPLY=${REPLY//\/.\//\/}
            ;;
            */.)
                REPLY=${REPLY%/.}
            ;;
            /..?(/*))
                REPLY=${REPLY#/..}
            ;;
            */+([^/])/../*)
                REPLY=${REPLY/\/+([^\/])\/..\//\/}
            ;;
            */+([^/])/..)
                REPLY=${REPLY%/+([^/])/..}
            ;;
            *)
                break
            ;;
        esac;
    done;
    [[ -n $REPLY ]] || REPLY=/
}
_comp_as_root () 
{ 
    [[ $EUID -eq 0 || -n ${_comp_root_command-} ]]
}
_comp_awk () 
{ 
    command awk "$@"
}
_comp_command () 
{ 
    local words;
    unset -v words;
    local offset i;
    offset=1;
    for ((i = 1; i <= COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            offset=$i;
            break;
        fi;
    done;
    _comp_command_offset $offset
}
_comp_command_offset () 
{ 
    local REPLY;
    _comp__find_original_word "$1";
    local word_offset=$REPLY;
    local COMP_LINE=$COMP_LINE COMP_POINT=$COMP_POINT COMP_CWORD=$COMP_CWORD;
    local -a comp_words=("${COMP_WORDS[@]}");
    local -a COMP_WORDS=("${comp_words[@]}");
    local i tail;
    for ((i = 0; i < word_offset; i++))
    do
        tail=${COMP_LINE#*"${COMP_WORDS[i]}"};
        ((COMP_POINT -= ${#COMP_LINE} - ${#tail}));
        COMP_LINE=$tail;
    done;
    COMP_WORDS=("${COMP_WORDS[@]:word_offset}");
    ((COMP_CWORD -= word_offset));
    COMPREPLY=();
    local cur;
    _comp_get_words cur;
    if ((COMP_CWORD == 0)); then
        _comp_compgen_commands;
    else
        _comp_dequote "${COMP_WORDS[0]}" || REPLY=${COMP_WORDS[0]};
        local cmd=$REPLY compcmd=$REPLY;
        local cspec=$(complete -p -- "$cmd" 2> /dev/null);
        if [[ ! -n $cspec && $cmd == */* ]]; then
            cspec=$(complete -p -- "${cmd##*/}" 2> /dev/null);
            [[ -n $cspec ]] && compcmd=${cmd##*/};
        fi;
        if [[ ! -n $cspec ]]; then
            compcmd=${cmd##*/};
            _comp_load -D -- "$compcmd";
            cspec=$(complete -p -- "$compcmd" 2> /dev/null);
        fi;
        local retry_count=0;
        while true; do
            local args original_cur=${comp_args[1]-$cur};
            if ((${#COMP_WORDS[@]} >= 2)); then
                args=("$cmd" "$original_cur" "${COMP_WORDS[-2]}");
            else
                args=("$cmd" "$original_cur");
            fi;
            if [[ ! -n $cspec ]]; then
                if ((${#COMPREPLY[@]} == 0)); then
                    _comp_complete_minimal "${args[@]}";
                fi;
            else
                if [[ $cspec == *\ -[CF]\ * ]]; then
                    if [[ $cspec == *' -F '* ]]; then
                        local func=${cspec#* -F };
                        func=${func%% *};
                        $func "${args[@]}";
                        if (($? == 124 && retry_count++ == 0)); then
                            COMPREPLY=();
                            cspec=$(complete -p -- "$compcmd" 2> /dev/null);
                            [[ -n $cspec ]] || break;
                            continue;
                        fi;
                    else
                        local completer=${cspec#* -C \'};
                        if ! _comp_dequote "'$completer"; then
                            _minimal "${args[@]}";
                            break;
                        fi;
                        completer=${REPLY[0]};
                        local -a suggestions;
                        local IFS=' 	
';
                        local reset_monitor=$(shopt -po monitor) reset_lastpipe=$(shopt -p lastpipe) reset_noglob=$(shopt -po noglob);
                        set +o monitor;
                        shopt -s lastpipe;
                        set -o noglob;
                        COMP_KEY="$COMP_KEY" COMP_LINE="$COMP_LINE" COMP_POINT="$COMP_POINT" COMP_TYPE="$COMP_TYPE" $completer "${args[@]}" | mapfile -t suggestions;
                        $reset_monitor;
                        $reset_lastpipe;
                        $reset_noglob;
                        _comp_unlocal IFS;
                        local suggestion;
                        local i=0;
                        COMPREPLY=();
                        for suggestion in "${suggestions[@]}";
                        do
                            COMPREPLY[i]+=${COMPREPLY[i]+'
'}$suggestion;
                            if [[ $suggestion != *\\ ]]; then
                                ((i++));
                            fi;
                        done;
                    fi;
                    local opt;
                    while [[ $cspec == *" -o "* ]]; do
                        cspec=${cspec#*-o };
                        opt=${cspec%% *};
                        compopt -o "$opt";
                        cspec=${cspec#"$opt"};
                    done;
                else
                    cspec=${cspec#complete};
                    cspec=${cspec%%@("$compcmd"|"'${compcmd//\'/\'\\\'\'}'")};
                    eval "_comp_compgen -- $cspec";
                fi;
            fi;
            break;
        done;
    fi
}
_comp_compgen () 
{ 
    local _append=;
    local _var=;
    local _cur=${_comp_compgen__cur-${cur-}};
    local _dir="";
    local _ifs=' 	
' _has_ifs="";
    local _icmd="" _xcmd="";
    local -a _upvars=();
    local _old_nocasematch="";
    if shopt -q nocasematch; then
        _old_nocasematch=set;
        shopt -u nocasematch;
    fi;
    local OPTIND=1 OPTARG="" OPTERR=0 _opt;
    while getopts ':av:U:Rc:C:lF:i:x:' _opt "$@"; do
        case $_opt in 
            a)
                _append=set
            ;;
            v)
                if [[ $OPTARG == @(*[^_a-zA-Z0-9]*|[0-9]*|''|_*|IFS|OPTIND|OPTARG|OPTERR|cur) ]]; then
                    printf 'bash_completion: %s: -v: invalid array name `%s'\''\n' "$FUNCNAME" "$OPTARG" 1>&2;
                    return 2;
                fi;
                _var=$OPTARG
            ;;
            U)
                if [[ $OPTARG == @(*[^_a-zA-Z0-9]*|[0-9]*|'') ]]; then
                    printf 'bash_completion: %s: -U: invalid variable name `%s'\''\n' "$FUNCNAME" "$OPTARG" 1>&2;
                    return 2;
                else
                    if [[ $OPTARG == @(_*|IFS|OPTIND|OPTARG|OPTERR|cur) ]]; then
                        printf 'bash_completion: %s: -U: unnecessary to mark `%s'\'' as upvar\n' "$FUNCNAME" "$OPTARG" 1>&2;
                        return 2;
                    fi;
                fi;
                _upvars+=("$OPTARG")
            ;;
            c)
                _cur=$OPTARG
            ;;
            R)
                _cur=""
            ;;
            C)
                if [[ ! -n $OPTARG ]]; then
                    printf 'bash_completion: %s: -C: invalid directory name `%s'\''\n' "$FUNCNAME" "$OPTARG" 1>&2;
                    return 2;
                fi;
                _dir=$OPTARG
            ;;
            l)
                _has_ifs=set _ifs='
'
            ;;
            F)
                _has_ifs=set _ifs=$OPTARG
            ;;
            [ix])
                if [[ ! -n $OPTARG ]]; then
                    printf 'bash_completion: %s: -%s: invalid command name `%s'\''\n' "$FUNCNAME" "$_opt" "$OPTARG" 1>&2;
                    return 2;
                else
                    if [[ -n $_icmd ]]; then
                        printf 'bash_completion: %s: -%s: `-i %s'\'' is already specified\n' "$FUNCNAME" "$_opt" "$_icmd" 1>&2;
                        return 2;
                    else
                        if [[ -n $_xcmd ]]; then
                            printf 'bash_completion: %s: -%s: `-x %s'\'' is already specified\n' "$FUNCNAME" "$_opt" "$_xcmd" 1>&2;
                            return 2;
                        fi;
                    fi;
                fi
            ;;&
            i)
                _icmd=$OPTARG
            ;;
            x)
                _xcmd=$OPTARG
            ;;
            *)
                printf 'bash_completion: %s: usage error\n' "$FUNCNAME" 1>&2;
                return 2
            ;;
        esac;
    done;
    [[ -n $_old_nocasematch ]] && shopt -s nocasematch;
    shift "$((OPTIND - 1))";
    if (($# == 0)); then
        printf 'bash_completion: %s: unexpected number of arguments\n' "$FUNCNAME" 1>&2;
        printf 'usage: %s [-alR|-F SEP|-v ARR|-c CUR] -- ARGS...' "$FUNCNAME" 1>&2;
        return 2;
    fi;
    if [[ ! -n $_var ]]; then
        _var=${_comp_compgen__var-COMPREPLY};
        [[ -n $_append ]] || _append=${_comp_compgen__append-};
    fi;
    if [[ $1 != -* ]]; then
        if [[ -n $_has_ifs ]]; then
            printf 'bash_completion: %s: `-l'\'' and `-F sep'\'' are not supported for generators\n' "$FUNCNAME" 1>&2;
            return 2;
        fi;
        local -a _generator;
        if [[ -n $_icmd ]]; then
            _generator=("_comp_cmd_${_icmd//[^a-zA-Z0-9_]/_}__compgen_$1");
        else
            if [[ -n $_xcmd ]]; then
                _generator=(_comp_xfunc "$_xcmd" "compgen_$1");
            else
                _generator=("_comp_compgen_$1");
            fi;
        fi;
        if ! declare -F -- "${_generator[0]}" &> /dev/null; then
            printf 'bash_completion: %s: unrecognized generator `%s'\'' (function %s not found)\n' "$FUNCNAME" "$1" "${_generator[0]}" 1>&2;
            return 2;
        fi;
        shift;
        _comp_compgen__call_generator "$@";
    else
        if [[ -n $_icmd || -n $_xcmd ]]; then
            printf 'bash_completion: %s: generator name is unspecified for `%s'\''\n' "$FUNCNAME" "${_icmd:+-i $_icmd}${_xcmd:+x $_xcmd}" 1>&2;
            return 2;
        fi;
        local IFS=' 	
';
        if [[ $* == *\$[0-9]* || $* == *\$\{[0-9]* ]]; then
            printf 'bash_completion: %s: positional parameter $1, $2, ... do not work inside this function\n' "$FUNCNAME" 1>&2;
            return 2;
        fi;
        _comp_compgen__call_builtin "$@";
    fi
}
_comp_compgen__call_builtin () 
{ 
    if [[ -n $_dir ]]; then
        local _original_pwd=$PWD;
        local PWD=${PWD-} OLDPWD=${OLDPWD-};
        command cd -- "$_dir" &> /dev/null || { 
            _comp_compgen__error_fallback;
            return
        };
    fi;
    local -a _result=();
    IFS=$_ifs compgen -V _result -X '' "$@" ${_cur:+-- "$_cur"} || { 
        _comp_compgen__error_fallback;
        return
    };
    [[ -n $_dir ]] && command cd -- "$_original_pwd";
    ((${#_upvars[@]})) && _comp_unlocal "${_upvars[@]}";
    ((${#_result[@]})) || return;
    if [[ -n $_append ]]; then
        eval -- "$_var+=(\"\${_result[@]}\")";
    else
        eval -- "$_var=(\"\${_result[@]}\")";
    fi;
    return
}
_comp_compgen__call_generator () 
{ 
    ((${#_upvars[@]})) && _comp_unlocal "${_upvars[@]}";
    if [[ -n $_dir ]]; then
        local _original_pwd=$PWD;
        local PWD=${PWD-} OLDPWD=${OLDPWD-};
        command cd -- "$_dir" &> /dev/null || { 
            _comp_compgen__error_fallback;
            return
        };
    fi;
    local _comp_compgen__append=$_append;
    local _comp_compgen__var=$_var;
    local _comp_compgen__cur=$_cur cur=$_cur;
    "${_generator[@]}" "$@";
    local _status=$?;
    [[ -n $_dir ]] && command cd -- "$_original_pwd";
    return "$_status"
}
_comp_compgen__error_fallback () 
{ 
    local _status=$?;
    if [[ -n $_append ]]; then
        eval -- "$_var+=()";
    else
        eval -- "$_var=()";
    fi;
    return "$_status"
}
_comp_compgen_allowed_groups () 
{ 
    if _comp_as_root; then
        _comp_compgen -- -g;
    else
        _comp_compgen_split -- "$(id -Gn 2> /dev/null || groups 2> /dev/null)";
    fi
}
_comp_compgen_allowed_users () 
{ 
    if _comp_as_root; then
        _comp_compgen -- -u;
    else
        _comp_compgen_split -- "$(id -un 2> /dev/null || whoami 2> /dev/null)";
    fi
}
_comp_compgen_available_interfaces () 
{ 
    local PATH=$PATH:/sbin;
    local generated;
    _comp_compgen -v generated split -- "$({ if [[ ${1-} == -w ]]; then
    iwconfig;
else
    if [[ ${1-} == -a ]]; then
        ip -c=never link show up || ip link show up || ifconfig;
    else
        ip -c=never link show || ip link show || ifconfig -a;
    fi;
fi; } 2> /dev/null | _comp_awk '/^[^ \t]/ { if ($1 ~ /^[0-9]+:/) { print $2 } else { print $1 } }')" && _comp_compgen -U generated set "${generated[@]%:}"
}
_comp_compgen_cd_devices () 
{ 
    _comp_compgen -c "${cur:-/dev/}" -- -f -d -X "!*/?([amrs])cd!(c-*)"
}
_comp_compgen_commands () 
{ 
    [[ ! -n ${cur-} ]] && shopt -q no_empty_cmd_completion && return 1;
    _comp_compgen -- -c -o plusdirs && compopt -o filenames
}
_comp_compgen_configured_interfaces () 
{ 
    local -a files;
    if [[ -f /etc/debian_version ]]; then
        _comp_expand_glob files '/etc/network/interfaces /etc/network/interfaces.d/*' || return 0;
        _comp_compgen -U files split -- "$(command sed -ne 's|^iface \([^ ]\{1,\}\).*$|\1|p' "${files[@]}" 2> /dev/null)";
    else
        if [[ -f /etc/SuSE-release ]]; then
            _comp_expand_glob files '/etc/sysconfig/network/ifcfg-*' || return 0;
            _comp_compgen -U files split -- "$(printf '%s\n' "${files[@]}" | command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p')";
        else
            if [[ -f /etc/pld-release ]]; then
                _comp_compgen -U files split -- "$(command ls -B /etc/sysconfig/interfaces | command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p')";
            else
                _comp_expand_glob files '/etc/sysconfig/network-scripts/ifcfg-*' || return 0;
                _comp_compgen -U files split -- "$(printf '%s\n' "${files[@]}" | command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p')";
            fi;
        fi;
    fi
}
_comp_compgen_dvd_devices () 
{ 
    _comp_compgen -c "${cur:-/dev/}" -- -f -d -X "!*/?(r)dvd*"
}
_comp_compgen_filedir () 
{ 
    _comp_compgen_tilde && return;
    local -a toks;
    local _arg=${1-};
    if [[ $_arg == -d ]]; then
        _comp_compgen -v toks -- -d;
    else
        local REPLY;
        _comp_quote_compgen "${cur-}";
        local _quoted=$REPLY;
        _comp_unlocal REPLY;
        [[ $_quoted == "''" ]] && _quoted="";
        local _xspec=${_arg:+"!*.@($_arg|${_arg^^})"} _plusdirs=();
        local _opts=(-f -X "$_xspec");
        [[ -n $_xspec ]] && _plusdirs=(-o plusdirs);
        [[ -n ${BASH_COMPLETION_FILEDIR_FALLBACK-} || ! -n ${_plusdirs-} ]] || _opts+=("${_plusdirs[@]}");
        _comp_compgen -v toks -c "$_quoted" -- "${_opts[@]}";
        [[ -n ${BASH_COMPLETION_FILEDIR_FALLBACK-} && -n $_arg && ${#toks[@]} -lt 1 ]] && _comp_compgen -av toks -c "$_quoted" -- -f ${_plusdirs+"${_plusdirs[@]}"};
    fi;
    if ((${#toks[@]} != 0)); then
        if [[ $cur != ?(*/).. ]]; then
            _comp_compgen -Rv toks -- -X '?(*/)@(.|..)' -W '"${toks[@]}"';
        fi;
    fi;
    if ((${#toks[@]} != 0)); then
        compopt -o filenames 2> /dev/null;
    fi;
    local IFS=' 	
';
    _comp_compgen -U toks set ${toks[@]+"${toks[@]}"}
}
_comp_compgen_filedir_xspec () 
{ 
    _comp_compgen_tilde && return;
    local REPLY;
    _comp_quote_compgen "$cur";
    local quoted=$REPLY;
    local xspec=${_comp_xspecs[${1##*/}]-${_xspecs[${1##*/}]-}};
    local -a toks;
    _comp_compgen -v toks -c "$quoted" -- -d;
    eval xspec="${xspec}";
    local matchop=!;
    if [[ $xspec == !* ]]; then
        xspec=${xspec#!};
        matchop=@;
    fi;
    xspec="$matchop($xspec|${xspec^^})";
    _comp_compgen -av toks -c "$quoted" -- -f -X "@(|!($xspec))";
    [[ -n ${BASH_COMPLETION_FILEDIR_FALLBACK-} && ${#toks[@]} -lt 1 ]] && _comp_compgen -av toks -c "$quoted" -- -f;
    ((${#toks[@]})) || return 1;
    if [[ $cur != ?(*/).. ]]; then
        _comp_compgen -Rv toks -- -X '?(*/)@(.|..)' -W '"${toks[@]}"' || return 1;
    fi;
    compopt -o filenames;
    _comp_compgen -RU toks -- -W '"${toks[@]}"'
}
_comp_compgen_fstypes () 
{ 
    local _fss;
    if [[ -e /proc/filesystems ]]; then
        _fss="$(cut -d'	' -f2 /proc/filesystems)
             $(_comp_awk '! /\*/ { print $NF }' /etc/filesystems 2> /dev/null)";
    else
        _fss="$(_comp_awk '/^[ \t]*[^#]/ { print $3 }' /etc/fstab 2> /dev/null)
             $(_comp_awk '/^[ \t]*[^#]/ { print $3 }' /etc/mnttab 2> /dev/null)
             $(_comp_awk '/^[ \t]*[^#]/ { print $4 }' /etc/vfstab 2> /dev/null)
             $(_comp_awk '{ print $1 }' /etc/dfs/fstypes 2> /dev/null)
             $(lsvfs 2> /dev/null | _comp_awk '$1 !~ /^(Filesystem|[^a-zA-Z])/ { print $1 }')
             $([[ -d /etc/fs ]] && command ls /etc/fs)";
    fi;
    [[ -n $_fss ]] && _comp_compgen_split -- "$_fss"
}
_comp_compgen_gids () 
{ 
    if type getent &> /dev/null; then
        _comp_compgen_split -- "$(getent group | cut -d: -f3)";
    else
        if type perl &> /dev/null; then
            _comp_compgen_split -- "$(perl -e 'while (($gid) = (getgrent)[2]) { print $gid . "\n" }')";
        else
            _comp_compgen_split -- "$(cut -d: -f3 /etc/group)";
        fi;
    fi
}
_comp_compgen_help () 
{ 
    (($#)) || set -- -- --help;
    local -a _lines;
    _comp_compgen_help__get_help_lines "$@" || return "$?";
    local -a options=();
    local _line;
    for _line in "${_lines[@]}";
    do
        [[ $_line == *([[:blank:]])-* ]] || continue;
        while [[ $_line =~ ((^|[^-])-[A-Za-z0-9?][[:space:]]+)\[?[A-Z0-9]+([,_-]+[A-Z0-9]+)?(\.\.+)?\]? ]]; do
            _line=${_line/"${BASH_REMATCH[0]}"/"${BASH_REMATCH[1]}"};
        done;
        _comp_compgen_help__parse "${_line// or /, }";
    done;
    ((${#options[@]})) || return 1;
    _comp_compgen -U options -- -W '"${options[@]}"';
    return 0
}
_comp_compgen_help__get_help_lines () 
{ 
    local -a help_cmd;
    case ${1-} in 
        -)
            if (($# > 1)); then
                printf 'bash_completion: %s -: extra arguments for -\n' "${FUNCNAME[1]}" 1>&2;
                printf 'usage: %s -\n' "${FUNCNAME[1]}" 1>&2;
                printf 'usage: %s -c cmd args...\n' "${FUNCNAME[1]}" 1>&2;
                printf 'usage: %s [-- args...]\n' "${FUNCNAME[1]}" 1>&2;
                return 2;
            fi;
            help_cmd=(exec cat)
        ;;
        -c)
            if (($# < 2)); then
                printf 'bash_completion: %s -c: no command is specified\n' "${FUNCNAME[1]}" 1>&2;
                printf 'usage: %s -\n' "${FUNCNAME[1]}" 1>&2;
                printf 'usage: %s -c cmd args...\n' "${FUNCNAME[1]}" 1>&2;
                printf 'usage: %s [-- args...]\n' "${FUNCNAME[1]}" 1>&2;
                return 2;
            fi;
            help_cmd=("${@:2}")
        ;;
        --)
            shift 1
        ;&
        *)
            local REPLY;
            _comp_dequote "${comp_args[0]-}" || REPLY=${comp_args[0]-};
            help_cmd=("${REPLY:-false}" "$@")
        ;;
    esac;
    local REPLY;
    _comp_split -l REPLY "$(LC_ALL=C "${help_cmd[@]}" 2>&1)" && _lines=("${REPLY[@]}")
}
_comp_compgen_help__parse () 
{ 
    local option option2 i;
    option=;
    local -a array;
    if _comp_split -F ' 	
,/|' array "$1"; then
        for i in "${array[@]}";
        do
            case "$i" in 
                ---*)
                    break
                ;;
                --?*)
                    option=$i;
                    break
                ;;
                -?*)
                    [[ -n $option ]] || option=$i
                ;;
                *)
                    break
                ;;
            esac;
        done;
    fi;
    [[ -n $option ]] || return 1;
    if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
        option2=${option/"${BASH_REMATCH[1]}"/};
        option2=${option2%%[<{().[]*};
        options+=("${option2/=*/=}");
        option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"};
    fi;
    [[ $option =~ ^([^=<{().[]|\.[A-Za-z0-9])+=? ]] && options+=("$BASH_REMATCH")
}
_comp_compgen_inserted_kernel_modules () 
{ 
    _comp_compgen -c "${1:-$cur}" split -- "$(PATH="$PATH:/sbin" lsmod | _comp_awk '{if (NR != 1) print $1}')"
}
_comp_compgen_ip_addresses () 
{ 
    local _n;
    case ${1-} in 
        -a)
            _n='6\{0,1\}'
        ;;
        -6)
            _n='6'
        ;;
        *)
            _n=
        ;;
    esac;
    local PATH=$PATH:/sbin;
    local addrs;
    _comp_compgen -v addrs split -- "$({ ip -c=never addr show || ip addr show || LC_ALL=C ifconfig -a; } 2> /dev/null | command sed -e 's/[[:space:]]addr:/ /' -ne "s|.*inet${_n}[[:space:]]\{1,\}\([^[:space:]/]*\).*|\1|p")" || return;
    if [[ ! -n $_n ]]; then
        _comp_compgen -U addrs set "${addrs[@]}";
    else
        _comp_compgen -U addrs ltrim_colon "${addrs[@]}";
    fi
}
_comp_compgen_kernel_modules () 
{ 
    local _modpath=/lib/modules/$1;
    _comp_compgen_split -- "$(command ls -RL "$_modpath" 2> /dev/null | command sed -ne 's/^\(.*\)\.k\{0,1\}o\(\.[gx]z\)\{0,1\}$/\1/p' -e 's/^\(.*\)\.ko\.zst$/\1/p')"
}
_comp_compgen_kernel_versions () 
{ 
    _comp_compgen_split -- "$(command ls /lib/modules)"
}
_comp_compgen_known_hosts () 
{ 
    local known_hosts;
    _comp_compgen_known_hosts__impl "$@" || return "$?";
    _comp_compgen -U known_hosts set "${known_hosts[@]}"
}
_comp_compgen_known_hosts__impl () 
{ 
    known_hosts=();
    local configfile="" flag prefix="";
    local cur suffix="" aliases="" i host ipv4="" ipv6="";
    local -a kh tmpkh=() khd=() config=();
    local OPTIND=1;
    while getopts "ac46F:p:" flag "$@"; do
        case $flag in 
            a)
                aliases=set
            ;;
            c)
                suffix=':'
            ;;
            F)
                if [[ ! -n $OPTARG ]]; then
                    echo "bash_completion: $FUNCNAME: -F: an empty filename is specified" 1>&2;
                    return 2;
                fi;
                configfile=$OPTARG
            ;;
            p)
                prefix=$OPTARG
            ;;
            4)
                ipv4=set
            ;;
            6)
                ipv6=set
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 2
            ;;
        esac;
    done;
    if (($# < OPTIND)); then
        echo "bash_completion: $FUNCNAME: missing mandatory argument CWORD" 1>&2;
        return 2;
    fi;
    cur=${!OPTIND};
    ((OPTIND += 1));
    if (($# >= OPTIND)); then
        echo "bash_completion: $FUNCNAME($*): unprocessed arguments:" "$(while (($# >= OPTIND)); do
    printf '%s ' ${!OPTIND}
shift;
done)" 1>&2;
        return 2;
    fi;
    [[ $cur == *@* ]] && prefix=$prefix${cur%@*}@ && cur=${cur#*@};
    kh=();
    if [[ -n $configfile ]]; then
        [[ -r $configfile && ! -d $configfile ]] && config+=("$configfile");
    else
        for i in /etc/ssh/ssh_config ~/.ssh/config ~/.ssh2/config;
        do
            [[ -r $i && ! -d $i ]] && config+=("$i");
        done;
    fi;
    if ((${#config[@]} > 0)); then
        for i in "${config[@]}";
        do
            _comp__included_ssh_config_files "$i";
        done;
    fi;
    if ((${#config[@]} > 0)); then
        if _comp_split -l tmpkh "$(_comp_awk 'sub("^[ \t]*([Gg][Ll][Oo][Bb][Aa][Ll]|[Uu][Ss][Ee][Rr])[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee][ \t=]+", "") { print $0 }' "${config[@]}" | sort -u)"; then
            local tmpkh2 j REPLY;
            for i in "${tmpkh[@]}";
            do
                while [[ $i =~ ^([^\"]*)\"([^\"]*)\"(.*)$ ]]; do
                    i=${BASH_REMATCH[1]}${BASH_REMATCH[3]};
                    _comp_expand_tilde "${BASH_REMATCH[2]}";
                    [[ -r $REPLY ]] && kh+=("$REPLY");
                done;
                _comp_split tmpkh2 "$i" || continue;
                for j in "${tmpkh2[@]}";
                do
                    _comp_expand_tilde "$j";
                    [[ -r $REPLY ]] && kh+=("$REPLY");
                done;
            done;
        fi;
    fi;
    if [[ ! -n $configfile ]]; then
        for i in /etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2 /etc/known_hosts /etc/known_hosts2 ~/.ssh/known_hosts ~/.ssh/known_hosts2;
        do
            [[ -r $i && ! -d $i ]] && kh+=("$i");
        done;
        for i in /etc/ssh2/knownhosts ~/.ssh2/hostkeys;
        do
            [[ -d $i ]] || continue;
            _comp_expand_glob tmpkh '"$i"/*.pub' && khd+=("${tmpkh[@]}");
        done;
    fi;
    if ((${#kh[@]} + ${#khd[@]} > 0)); then
        if ((${#kh[@]} > 0)); then
            for i in "${kh[@]}";
            do
                while read -ra tmpkh; do
                    ((${#tmpkh[@]} == 0)) && continue;
                    [[ ${tmpkh[0]} == [\|\#]* ]] && continue;
                    local host_list=${tmpkh[0]};
                    [[ ${tmpkh[0]} == @* ]] && host_list=${tmpkh[1]-};
                    local -a hosts;
                    if _comp_split -F , hosts "$host_list"; then
                        for host in "${hosts[@]}";
                        do
                            [[ $host == *[*?]* ]] && continue;
                            host=${host#[};
                            host=${host%]?(:+([0-9]))};
                            [[ -n $host ]] && known_hosts+=("$host");
                        done;
                    fi;
                done < "$i";
            done;
        fi;
        if ((${#khd[@]} > 0)); then
            for i in "${khd[@]}";
            do
                if [[ $i == *key_22_*.pub && -r $i ]]; then
                    host=${i/#*key_22_/};
                    host=${host/%.pub/};
                    [[ -n $host ]] && known_hosts+=("$host");
                fi;
            done;
        fi;
        ((${#known_hosts[@]})) && _comp_compgen -v known_hosts -- -W '"${known_hosts[@]}"' -P "$prefix" -S "$suffix";
    fi;
    if [[ ${#config[@]} -gt 0 && -n $aliases ]]; then
        local -a hosts;
        if _comp_split hosts "$(command sed -ne 's/^[[:blank:]]*[Hh][Oo][Ss][Tt][[:blank:]=]\{1,\}\(.*\)$/\1/p' "${config[@]}")"; then
            _comp_compgen -av known_hosts -- -P "$prefix" -S "$suffix" -W '"${hosts[@]%%[*?%]*}"' -X '@(\!*|)';
        fi;
    fi;
    if [[ -n ${BASH_COMPLETION_KNOWN_HOSTS_WITH_AVAHI-} ]] && type avahi-browse &> /dev/null; then
        local generated=$(avahi-browse -cprak 2> /dev/null | _comp_awk -F ';' '/^=/ && $5 ~ /^_(ssh|workstation)\._tcp$/ { print $7 }' | sort -u);
        _comp_compgen -av known_hosts -- -P "$prefix" -S "$suffix" -W '$generated';
    fi;
    if type ruptime &> /dev/null; then
        local generated=$(ruptime 2> /dev/null | _comp_awk '!/^ruptime:/ { print $1 }');
        _comp_compgen -av known_hosts -- -W '$generated';
    fi;
    if [[ -n ${BASH_COMPLETION_KNOWN_HOSTS_WITH_HOSTFILE-set} ]]; then
        _comp_compgen -av known_hosts -- -A hostname -P "$prefix" -S "$suffix";
    fi;
    ((${#known_hosts[@]})) || return 1;
    if [[ -n $ipv4 ]]; then
        known_hosts=("${known_hosts[@]/*:*$suffix/}");
    fi;
    if [[ -n $ipv6 ]]; then
        known_hosts=("${known_hosts[@]/+([0-9]).+([0-9]).+([0-9]).+([0-9])$suffix/}");
    fi;
    if [[ -n $ipv4 || -n $ipv6 ]]; then
        for i in "${!known_hosts[@]}";
        do
            [[ -n ${known_hosts[i]} ]] || unset -v 'known_hosts[i]';
        done;
    fi;
    ((${#known_hosts[@]})) || return 1;
    _comp_compgen -v known_hosts -c "$prefix$cur" ltrim_colon "${known_hosts[@]}"
}
_comp_compgen_ltrim_colon () 
{ 
    (($#)) || return 0;
    local -a _tmp;
    _tmp=("$@");
    if [[ $cur == *:* && $COMP_WORDBREAKS == *:* ]]; then
        local _colon_word=${cur%"${cur##*:}"};
        _tmp=("${_tmp[@]#"$_colon_word"}");
    fi;
    _comp_compgen_set "${_tmp[@]}"
}
_comp_compgen_mac_addresses () 
{ 
    local _re='\([A-Fa-f0-9]\{2\}:\)\{5\}[A-Fa-f0-9]\{2\}';
    local PATH="$PATH:/sbin:/usr/sbin";
    local -a addresses;
    _comp_compgen -v addresses split -- "$({ ip -c=never link show || ip link show || LC_ALL=C ifconfig -a; } 2> /dev/null | command sed -ne "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($_re\)[[:space:]].*/\1/p" -ne "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($_re\)[[:space:]]*$/\1/p" -ne "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($_re\)[[:space:]].*|\2|p" -ne "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($_re\)[[:space:]]*$|\2|p")";
    _comp_compgen -av addresses split -- "$({ arp -an || ip -c=never neigh show || ip neigh show; } 2> /dev/null | command sed -ne "s/.*[[:space:]]\($_re\)[[:space:]].*/\1/p" -ne "s/.*[[:space:]]\($_re\)[[:space:]]*$/\1/p")";
    _comp_compgen -av addresses split -- "$(command sed -ne "s/^[[:space:]]*\($_re\)[[:space:]].*/\1/p" /etc/ethers 2> /dev/null)";
    _comp_compgen -U addresses ltrim_colon "${addresses[@]}"
}
_comp_compgen_pci_ids () 
{ 
    _comp_compgen_split -- "$(PATH="$PATH:/sbin" lspci -n | _comp_awk '{print $3}')"
}
_comp_compgen_pgids () 
{ 
    _comp_compgen_split -- "$(command ps ax -o pgid=)"
}
_comp_compgen_pids () 
{ 
    _comp_compgen_split -- "$(command ps ax -o pid=)"
}
_comp_compgen_pnames () 
{ 
    local -a procs=();
    if [[ ${1-} == -s ]]; then
        _comp_split procs "$(command ps ax -o comm | command sed -e 1d)";
    else
        local -a psout;
        _comp_split -l psout "$({ command ps ax -o command= || command ps ax -o comm=; } 2> /dev/null)";
        local line i=-1;
        for line in "${psout[@]}";
        do
            if ((i == -1)); then
                if [[ $line =~ ^(.*[[:space:]])COMMAND([[:space:]]|$) ]]; then
                    i=${#BASH_REMATCH[1]};
                else
                    break;
                fi;
            else
                line=${line:i};
                line=${line%% *};
                [[ -n $line ]] && procs+=("$line");
            fi;
        done;
        if ((i == -1)); then
            for line in "${psout[@]}";
            do
                if [[ $line =~ ^[[(](.+)[])]$ ]]; then
                    procs+=("${BASH_REMATCH[1]}");
                else
                    line=${line%% *};
                    line=${line##@(*/|-)};
                    [[ -n $line ]] && procs+=("$line");
                fi;
            done;
        fi;
    fi;
    ((${#procs[@]})) && _comp_compgen -U procs -- -X "<defunct>" -W '"${procs[@]}"'
}
_comp_compgen_selinux_users () 
{ 
    _comp_compgen_split -- "$(semanage user -nl 2> /dev/null | _comp_awk '{ print $1 }')"
}
_comp_compgen_services () 
{ 
    local sysvdirs;
    _comp_sysvdirs || return 1;
    local services;
    _comp_expand_glob services '${sysvdirs[0]}/!($_comp_backup_glob|functions|README)';
    local _generated=$({ systemctl list-units --full --all || systemctl list-unit-files; } 2> /dev/null | _comp_awk '$1 ~ /\.service$/ { sub("\\.service$", "", $1); print $1 }');
    _comp_split -la services "$_generated";
    if [[ -x /sbin/upstart-udev-bridge ]]; then
        _comp_split -la services "$(initctl list 2> /dev/null | cut -d' ' -f1)";
    fi;
    ((${#services[@]})) || return 1;
    _comp_compgen -U services -U sysvdirs -- -W '"${services[@]#${sysvdirs[0]}/}"'
}
_comp_compgen_set () 
{ 
    local _append=${_comp_compgen__append-};
    local _var=${_comp_compgen__var-COMPREPLY};
    eval -- "$_var${_append:++}=(\"\$@\")";
    (($#))
}
_comp_compgen_shells () 
{ 
    local -a shells=();
    local _shell _rest;
    while read -r _shell _rest; do
        [[ $_shell == /* ]] && shells+=("$_shell");
    done 2> /dev/null < "${1-}"/etc/shells;
    _comp_compgen -U shells -- -W '"${shells[@]}"'
}
_comp_compgen_signals () 
{ 
    local -a sigs;
    _comp_compgen -v sigs -c "SIG${cur#"${1-}"}" -- -A signal && _comp_compgen -RU sigs -- -P "${1-}" -W '"${sigs[@]#SIG}"'
}
_comp_compgen_split () 
{ 
    local _ifs=' 	
';
    local -a _compgen_options=();
    local OPTIND=1 OPTARG="" OPTERR=0 _opt;
    while getopts ':lF:X:S:P:o:' _opt "$@"; do
        case $_opt in 
            l)
                _ifs='
'
            ;;
            F)
                _ifs=$OPTARG
            ;;
            [XSPo])
                _compgen_options+=("-$_opt" "$OPTARG")
            ;;
            *)
                printf 'bash_completion: usage: %s [-l|-F sep] [--] str\n' "$FUNCNAME" 1>&2;
                return 2
            ;;
        esac;
    done;
    shift "$((OPTIND - 1))";
    if (($# != 1)); then
        printf 'bash_completion: %s: unexpected number of arguments.\n' "$FUNCNAME" 1>&2;
        printf 'usage: %s [-l|-F sep] [--] str' "$FUNCNAME" 1>&2;
        return 2;
    fi;
    local input=$1 IFS=' 	
';
    _comp_compgen -F "$_ifs" -U input -- ${_compgen_options[@]+"${_compgen_options[@]}"} -W '$input'
}
_comp_compgen_terms () 
{ 
    _comp_compgen_split -- "$({ command sed -ne 's/^\([^[:space:]#|]\{2,\}\)|.*/\1/p' /etc/termcap
{ toe -a || toe; } | _comp_awk '{ print $1 }'
_comp_expand_glob dirs '/{etc,lib,usr/lib,usr/share}/terminfo/?' && find "${dirs[@]}" -type f -maxdepth 1 | _comp_awk -F / '{ print $NF }'; } 2> /dev/null)"
}
_comp_compgen_tilde () 
{ 
    if [[ ${cur-} == \~* && $cur != */* ]]; then
        if _comp_compgen -c "${cur#\~}" -- -P '~' -u; then
            compopt -o filenames 2> /dev/null;
            return 0;
        fi;
    fi;
    return 1
}
_comp_compgen_uids () 
{ 
    if type getent &> /dev/null; then
        _comp_compgen_split -- "$(getent passwd | cut -d: -f3)";
    else
        if type perl &> /dev/null; then
            _comp_compgen_split -- "$(perl -e 'while (($uid) = (getpwent)[2]) { print $uid . "\n" }')";
        else
            _comp_compgen_split -- "$(cut -d: -f3 /etc/passwd)";
        fi;
    fi
}
_comp_compgen_usage () 
{ 
    (($#)) || set -- -- --usage;
    local -a _lines;
    _comp_compgen_help__get_help_lines "$@" || return "$?";
    local -a options=();
    local _line _match _option _i _char;
    for _line in "${_lines[@]}";
    do
        while [[ $_line =~ \[[[:space:]]*(-[^]]+)[[:space:]]*\] ]]; do
            _match=${BASH_REMATCH[0]};
            _option=${BASH_REMATCH[1]};
            case $_option in 
                -?(\[)+([a-zA-Z0-9?]))
                    for ((_i = 1; _i < ${#_option}; _i++))
                    do
                        _char=${_option:_i:1};
                        [[ $_char != '[' ]] && options+=("-$_char");
                    done
                ;;
                *)
                    _comp_compgen_help__parse "$_option"
                ;;
            esac;
            _line=${_line#*"$_match"};
        done;
    done;
    ((${#options[@]})) || return 1;
    _comp_compgen -U options -- -W '"${options[@]}"';
    return 0
}
_comp_compgen_usb_ids () 
{ 
    _comp_compgen_split -- "$(PATH="$PATH:/sbin" lsusb | _comp_awk '{print $6}')"
}
_comp_compgen_usergroups () 
{ 
    if [[ $cur == *\\\\* || $cur == *:*:* ]]; then
        return;
    else
        if [[ $cur == *\\:* ]]; then
            local tmp;
            if [[ ${1-} == -u ]]; then
                _comp_compgen -v tmp -c "${cur#*:}" allowed_groups;
            else
                _comp_compgen -v tmp -c "${cur#*:}" -- -g;
            fi;
            if ((${#tmp[@]})); then
                local _prefix=${cur%%*([^:])};
                _prefix=${_prefix//\\/};
                _comp_compgen -Rv tmp -- -P "$_prefix" -W '"${tmp[@]}"';
                _comp_compgen -U tmp set "${tmp[@]}";
            fi;
        else
            if [[ $cur == *:* ]]; then
                if [[ ${1-} == -u ]]; then
                    _comp_compgen -c "${cur#*:}" allowed_groups;
                else
                    _comp_compgen -c "${cur#*:}" -- -g;
                fi;
            else
                if [[ ${1-} == -u ]]; then
                    _comp_compgen_allowed_users;
                else
                    _comp_compgen -- -u;
                fi;
            fi;
        fi;
    fi
}
_comp_compgen_variables () 
{ 
    if [[ $cur =~ ^(\$(\{[!#]?)?)([A-Za-z0-9_]*)$ ]]; then
        if [[ $cur == '${'* ]]; then
            local arrs vars;
            _comp_compgen -v vars -c "${BASH_REMATCH[3]}" -- -A variable -P "${BASH_REMATCH[1]}" -S '}';
            _comp_compgen -v arrs -c "${BASH_REMATCH[3]}" -- -A arrayvar -P "${BASH_REMATCH[1]}" -S '[';
            if ((${#vars[@]} == 1 && ${#arrs[@]} != 0)); then
                compopt -o nospace;
                _comp_compgen -U vars -U arrs -R -- -W '"${arrs[@]}"';
            else
                _comp_compgen -U vars -U arrs -R -- -W '"${vars[@]}"';
            fi;
        else
            _comp_compgen -ac "${BASH_REMATCH[3]}" -- -A variable -P '$';
        fi;
        return 0;
    else
        if [[ $cur =~ ^(\$\{[#!]?)([A-Za-z0-9_]*)\[([^]]*)$ ]]; then
            local vars;
            _comp_compgen -v vars -c "${BASH_REMATCH[3]}" -- -W '"${!'"${BASH_REMATCH[2]}"'[@]}"' -P "${BASH_REMATCH[1]}${BASH_REMATCH[2]}[" -S ']}';
            if [[ ${BASH_REMATCH[3]} == [@*] ]]; then
                vars+=("${BASH_REMATCH[1]}${BASH_REMATCH[2]}[${BASH_REMATCH[3]}]}");
            fi;
            if ((${#vars[@]})); then
                _comp_compgen -U vars -c "$cur" ltrim_colon "${vars[@]}";
            else
                _comp_compgen_set;
            fi;
            return 0;
        else
            if [[ $cur =~ ^\$\{[#!]?[A-Za-z0-9_]*\[.*\]$ ]]; then
                _comp_compgen -c "$cur" ltrim_colon "$cur}";
                return 0;
            fi;
        fi;
    fi;
    return 1
}
_comp_compgen_xinetd_services () 
{ 
    local xinetddir=${_comp__test_xinetd_dir:-/etc/xinetd.d};
    if [[ -d $xinetddir ]]; then
        local -a svcs;
        if _comp_expand_glob svcs '$xinetddir/!($_comp_backup_glob)'; then
            _comp_compgen -U svcs -U xinetddir -- -W '"${svcs[@]#$xinetddir/}"';
        fi;
    fi
}
_comp_complete_filedir_xspec () 
{ 
    local cur prev words cword comp_args;
    _comp_initialize -- "$@" || return;
    _comp_compgen_filedir_xspec "$1"
}
_comp_complete_known_hosts () 
{ 
    local cur prev words cword comp_args;
    _comp_initialize -n : -- "$@" || return;
    local -a options=();
    [[ ${1-} == -a || ${2-} == -a ]] && options+=(-a);
    [[ ${1-} == -c || ${2-} == -c ]] && options+=(-c);
    local IFS=' 	
';
    _comp_compgen_known_hosts ${options[@]+"${options[@]}"} -- "$cur"
}
_comp_complete_load () 
{ 
    local cmd=${1:-_EmptycmD_};
    _comp_load -D -- "$cmd" && return 124
}
_comp_complete_longopt () 
{ 
    local cur prev words cword was_split comp_args;
    _comp_initialize -s -- "$@" || return;
    case "${prev,,}" in 
        --help | --usage | --version)
            return
        ;;
        --!(no-*)dir*)
            _comp_compgen -a filedir -d;
            return
        ;;
        --!(no-*)@(file|path)*)
            _comp_compgen -a filedir;
            return
        ;;
        --+([-a-z0-9_]))
            local argtype=$(LC_ALL=C $1 --help 2>&1 | command sed -ne "s|.*$prev\[\{0,1\}=[<[]\{0,1\}\([-A-Za-z0-9_]\{1,\}\).*|\1|p");
            case ${argtype,,} in 
                *dir*)
                    _comp_compgen -a filedir -d;
                    return
                ;;
                *file* | *path*)
                    _comp_compgen -a filedir;
                    return
                ;;
            esac
        ;;
    esac;
    [[ -n $was_split ]] && return;
    if [[ $cur == -* ]]; then
        _comp_compgen_split -- "$(LC_ALL=C $1 --help 2>&1 | while read -r line; do
    [[ $line =~ --[A-Za-z0-9]+([-_][A-Za-z0-9]+)*=? ]] && printf '%s\n' "${BASH_REMATCH[0]}";
done)";
        [[ ${COMPREPLY-} == *= ]] && compopt -o nospace;
    else
        if [[ $1 == *@(rmdir|chroot) ]]; then
            _comp_compgen -a filedir -d;
        else
            [[ $1 == *mkdir ]] && compopt -o nospace;
            _comp_compgen -a filedir;
        fi;
    fi
}
_comp_complete_minimal () 
{ 
    local cur prev words cword comp_args;
    _comp_initialize -- "$@" || return;
    compopt -o bashdefault -o default
}
_comp_complete_service () 
{ 
    local cur prev words cword comp_args;
    _comp_initialize -- "$@" || return;
    ((cword > 2)) && return;
    if [[ $cword -eq 1 && $prev == ?(*/)service ]]; then
        _comp_compgen_services;
        [[ -e /etc/mandrake-release ]] && _comp_compgen_xinetd_services;
    else
        local sysvdirs;
        _comp_sysvdirs || return 1;
        _comp_compgen_split -l -- "$(command sed -e 'y/|/ /' -ne 's/^.*\(U\|msg_u\)sage.*{\(.*\)}.*$/\2/p' "${sysvdirs[0]}/${prev##*/}" 2> /dev/null) start stop";
    fi
}
_comp_complete_user_at_host () 
{ 
    local cur prev words cword comp_args;
    _comp_initialize -n : -- "$@" || return;
    if [[ $cur == *@* ]]; then
        _comp_compgen_known_hosts "$cur";
    else
        _comp_compgen -- -u -S @;
        compopt -o nospace;
    fi
}
_comp_count_args () 
{ 
    local has_optarg="" has_exclude="" exclude="" glob_include="";
    local OPTIND=1 OPTARG="" OPTERR=0 _opt;
    while getopts ':a:n:i:' _opt "$@"; do
        case $_opt in 
            a)
                has_optarg=$OPTARG
            ;;
            n)
                has_exclude=set exclude+=$OPTARG
            ;;
            i)
                glob_include=$OPTARG
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 2
            ;;
        esac;
    done;
    shift "$((OPTIND - 1))";
    if [[ -n $has_exclude ]]; then
        local cword words;
        _comp__reassemble_words "$exclude<>&" words cword;
    fi;
    local i;
    REPLY=1;
    for ((i = 1; i < cword; i++))
    do
        if [[ -n $has_optarg && ${words[i]} == $has_optarg ]]; then
            ((i++));
        else
            if [[ ${words[i]} != -?* || -n $glob_include && ${words[i]} == $glob_include ]]; then
                ((REPLY++));
            else
                if [[ ${words[i]} == -- ]]; then
                    ((REPLY += cword - i - 1));
                    break;
                fi;
            fi;
        fi;
    done
}
_comp_delimited () 
{ 
    local prefix="" delimiter=$1 deduplicate=set;
    shift;
    if [[ $delimiter == -k ]]; then
        deduplicate="";
        delimiter=$1;
        shift;
    fi;
    [[ $cur == *"$delimiter"* ]] && prefix=${cur%"$delimiter"*}$delimiter;
    if [[ -n $deduplicate ]]; then
        _comp_compgen -R -- "$@";
        local -a existing;
        _comp_split -F "$delimiter" existing "$cur";
        [[ ! -n $cur || $cur == *"$delimiter" ]] || unset -v "existing[${#existing[@]}-1]";
        if ((${#COMPREPLY[@]})); then
            local x i;
            for x in ${existing+"${existing[@]}"};
            do
                for i in "${!COMPREPLY[@]}";
                do
                    if [[ $x == "${COMPREPLY[i]}" ]]; then
                        unset -v 'COMPREPLY[i]';
                        continue 2;
                    fi;
                done;
            done;
            ((${#COMPREPLY[@]})) && _comp_compgen -c "${cur##*"$delimiter"}" -- -W '"${COMPREPLY[@]}"';
        fi;
    else
        _comp_compgen -c "${cur##*"$delimiter"}" -- "$@";
    fi;
    local i;
    for i in "${!COMPREPLY[@]}";
    do
        COMPREPLY[i]="$prefix${COMPREPLY[i]}";
    done;
    [[ $delimiter != : ]] || _comp_ltrim_colon_completions "$cur"
}
_comp_deprecate_func () 
{ 
    if (($# != 3)); then
        printf 'bash_completion: %s: usage: %s DEPRECATION_VERSION OLD_NAME NEW_NAME\n' "$FUNCNAME" "$FUNCNAME";
        return 2;
    fi;
    if [[ $2 != [a-zA-Z_]*([a-zA-Z_0-9]) ]]; then
        printf 'bash_completion: %s: %s\n' "$FUNCNAME" "\$2: invalid function name '$1'" 1>&2;
        return 2;
    else
        if [[ $3 != [a-zA-Z_]*([a-zA-Z_0-9]) ]]; then
            printf 'bash_completion: %s: %s\n' "$FUNCNAME" "\$3: invalid function name '$2'" 1>&2;
            return 2;
        fi;
    fi;
    eval -- "$2() { $3 \"\$@\"; }"
}
_comp_deprecate_var () 
{ 
    if (($# != 3)); then
        printf 'bash_completion: %s: usage: %s DEPRECATION_VERSION OLD_NAME NEW_NAME\n' "$FUNCNAME" "$FUNCNAME";
        return 2;
    fi;
    if [[ $2 != [a-zA-Z_]*([a-zA-Z_0-9]) ]]; then
        printf 'bash_completion: %s: %s\n' "$FUNCNAME" "\$2: invalid variable name '$1'" 1>&2;
        return 2;
    else
        if [[ $3 != [a-zA-Z_]*([a-zA-Z_0-9]) ]]; then
            printf 'bash_completion: %s: %s\n' "$FUNCNAME" "\$3: invalid variable name '$2'" 1>&2;
            return 2;
        fi;
    fi;
    if ((BASH_VERSINFO[0] >= 5 || BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] >= 3)); then
        eval "declare -gn $2=$3";
    else
        if [[ -v $2 && ! -v $3 ]]; then
            printf -v "$3" %s "$2";
        fi;
    fi
}
_comp_dequote () 
{ 
    REPLY=();
    [[ $1 =~ $_comp_dequote__regex_safe_word ]] || return 1;
    eval "REPLY=($1)" 2> /dev/null
}
_comp_expand () 
{ 
    case ${cur-} in 
        ~*/*)
            local REPLY;
            _comp_expand_tilde "$cur";
            cur=$REPLY
        ;;
        ~*)
            _comp_compgen -v COMPREPLY tilde && eval "COMPREPLY[0]=$(printf ~%q "${COMPREPLY[0]#\~}")" && return 1
        ;;
    esac;
    return 0
}
_comp_expand_glob () 
{ 
    if (($# != 2)); then
        printf 'bash-completion: %s: unexpected number of arguments\n' "$FUNCNAME" 1>&2;
        printf 'usage: %s ARRAY_NAME PATTERN\n' "$FUNCNAME" 1>&2;
        return 2;
    else
        if [[ $1 == @(GLOBIGNORE|GLOBSORT|_*|*[^_a-zA-Z0-9]*|[0-9]*|'') ]]; then
            printf 'bash-completion: %s: invalid array name "%s"\n' "$FUNCNAME" "$1" 1>&2;
            return 2;
        fi;
    fi;
    local _original_opts=$SHELLOPTS:$BASHOPTS;
    set +o noglob;
    shopt -s nullglob;
    shopt -u failglob dotglob;
    local GLOBIGNORE="" GLOBSORT=name;
    local LC_COLLATE=C LC_CTYPE=${LC_ALL:-${LC_CTYPE:-${LANG-}}} LC_ALL=;
    eval -- "$1=()";
    eval -- "$1=($2)";
    _comp_unlocal GLOBIGNORE;
    if [[ :$_original_opts: == *:dotglob:* ]]; then
        shopt -s dotglob;
    else
        shopt -u dotglob;
    fi;
    [[ :$_original_opts: == *:nullglob:* ]] || shopt -u nullglob;
    [[ :$_original_opts: == *:failglob:* ]] && shopt -s failglob;
    [[ :$_original_opts: == *:noglob:* ]] && set -o noglob;
    eval "((\${#$1[@]}))"
}
_comp_expand_tilde () 
{ 
    REPLY=$1;
    if [[ $1 == \~* ]]; then
        printf -v REPLY '~%q' "${1#\~}";
        eval "REPLY=$REPLY";
    fi
}
_comp_get_first_arg () 
{ 
    _comp_locate_first_arg "$@" && REPLY=${words[REPLY]}
}
_comp_get_ncpus () 
{ 
    local var=NPROCESSORS_ONLN;
    [[ $OSTYPE == *@(linux|msys|cygwin)* ]] && var=_$var;
    if REPLY=$(getconf $var 2> /dev/null) && ((REPLY >= 1)); then
        return 0;
    else
        REPLY=1;
        return 1;
    fi
}
_comp_get_words () 
{ 
    local exclude="" flag i OPTIND=1;
    local cur cword words=();
    local upargs=() upvars=() vcur="" vcword="" vprev="" vwords="";
    while getopts "c:i:n:p:w:" flag "$@"; do
        case $flag in 
            [cipw])
                if [[ $OPTARG != [a-zA-Z_]*([a-zA-Z_0-9])?(\[*\]) ]]; then
                    echo "bash_completion: $FUNCNAME: -$flag: invalid variable name \`$OPTARG'" 1>&2;
                    return 1;
                fi
            ;;&
            c)
                vcur=$OPTARG
            ;;
            i)
                vcword=$OPTARG
            ;;
            n)
                exclude=$OPTARG
            ;;
            p)
                vprev=$OPTARG
            ;;
            w)
                vwords=$OPTARG
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 1
            ;;
        esac;
    done;
    while [[ $# -ge $OPTIND ]]; do
        case ${!OPTIND} in 
            cur)
                vcur=cur
            ;;
            prev)
                vprev=prev
            ;;
            cword)
                vcword=cword
            ;;
            words)
                vwords=words
            ;;
            *)
                echo "bash_completion: $FUNCNAME: \`${!OPTIND}':" "unknown argument" 1>&2;
                return 1
            ;;
        esac;
        ((OPTIND += 1));
    done;
    _comp__get_cword_at_cursor "${exclude-}" words cword cur;
    [[ -n $vcur ]] && { 
        upvars+=("$vcur");
        upargs+=(-v "$vcur" "$cur")
    };
    [[ -n $vcword ]] && { 
        upvars+=("$vcword");
        upargs+=(-v "$vcword" "$cword")
    };
    [[ -n $vprev ]] && { 
        local value="";
        ((cword >= 1)) && value=${words[cword - 1]};
        upvars+=("$vprev");
        upargs+=(-v "$vprev" "$value")
    };
    [[ -n $vwords ]] && { 
        local IFS=' 	
';
        upvars+=("$vwords");
        upargs+=(-a"${#words[@]}" "$vwords" ${words+"${words[@]}"})
    };
    ((${#upvars[@]})) && local "${upvars[@]}" && _comp_upvars "${upargs[@]}"
}
_comp_have_command () 
{ 
    PATH=$PATH:/usr/sbin:/sbin:/usr/local/sbin type "$1" &> /dev/null
}
_comp_initialize () 
{ 
    local exclude="" opt_split="" outx="" errx="" inx="";
    local flag OPTIND=1 OPTARG="" OPTERR=0;
    while getopts "n:e:o:i:s" flag "$@"; do
        case $flag in 
            n)
                exclude+=$OPTARG
            ;;
            e)
                errx=$OPTARG
            ;;
            o)
                outx=$OPTARG
            ;;
            i)
                inx=$OPTARG
            ;;
            s)
                opt_split="set";
                was_split="";
                exclude+="="
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 1
            ;;
        esac;
    done;
    shift "$((OPTIND - 1))";
    (($#)) && comp_args=("$@");
    COMPREPLY=();
    local redir='@(?(+([0-9])|{[a-zA-Z_]*([a-zA-Z_0-9])})@(>?([>|&])|<?([>&])|<<?([-<]))|&>?(>))';
    _comp_get_words -n "$exclude<>&" cur prev words cword;
    _comp_compgen_variables && return 1;
    if [[ $cur == $redir* || ${prev-} == $redir ]]; then
        local xspec;
        case $cur in 
            2'>'*)
                xspec=${errx-}
            ;;
            *'>'*)
                xspec=${outx-}
            ;;
            *'<'*)
                xspec=${inx-}
            ;;
            *)
                case $prev in 
                    2'>'*)
                        xspec=${errx-}
                    ;;
                    *'>'*)
                        xspec=${outx-}
                    ;;
                    *'<'*)
                        xspec=${inx-}
                    ;;
                esac
            ;;
        esac;
        cur=${cur##$redir};
        _comp_compgen_filedir "$xspec";
        return 1;
    fi;
    local i skip;
    for ((i = 1; i < ${#words[@]}; 1))
    do
        if [[ ${words[i]} == $redir* ]]; then
            [[ ${words[i]} == $redir ]] && skip=2 || skip=1;
            words=("${words[@]:0:i}" "${words[@]:i+skip}");
            ((i <= cword)) && ((cword -= skip));
        else
            ((i++));
        fi;
    done;
    ((cword <= 0)) && return 1;
    prev=${words[cword - 1]};
    [[ -n $opt_split ]] && _comp__split_longopt && was_split="set";
    return 0
}
_comp_load () 
{ 
    local flag_fallback_default="" IFS=' 	
';
    local OPTIND=1 OPTARG="" OPTERR=0 opt;
    while getopts ':D' opt "$@"; do
        case $opt in 
            D)
                flag_fallback_default=set
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 2
            ;;
        esac;
    done;
    shift "$((OPTIND - 1))";
    local cmd=$1 cmdname=${1##*/} dir compfile;
    local -a paths;
    [[ -n $cmdname ]] || return 1;
    local backslash=;
    if [[ $cmd == \\* ]]; then
        cmd=${cmd:1};
        $(complete -p -- "$cmd" 2> /dev/null || echo false) "\\$cmd" && return 0;
        backslash=\\;
    fi;
    local REPLY pathcmd origcmd=$cmd;
    if pathcmd=$(type -P -- "$cmd"); then
        _comp_abspath "$pathcmd";
        cmd=$REPLY;
    fi;
    local -a dirs=();
    if [[ -n ${BASH_COMPLETION_USER_DIR-} ]]; then
        _comp_split -F : paths "$BASH_COMPLETION_USER_DIR" && dirs+=("${paths[@]/%//completions}");
    else
        dirs=("${XDG_DATA_HOME:-$HOME/.local/share}/bash-completion/completions");
    fi;
    dirs+=("$_comp__base_directory/completions");
    paths=();
    [[ $cmd == /* ]] && paths+=("${cmd%/*}");
    _comp_realcommand "$cmd" && paths+=("${REPLY%/*}");
    _comp_split -aF : paths "$PATH";
    for dir in "${paths[@]%/}";
    do
        [[ $dir == ?*/@(bin|sbin) ]] && dirs+=("${dir%/*}/share/bash-completion/completions");
    done;
    _comp_split -F : paths "${XDG_DATA_DIRS:-/usr/local/share:/usr/share}" && dirs+=("${paths[@]/%//bash-completion/completions}");
    local IFS=' 	
';
    shift;
    local i prefix compspec;
    for prefix in "" _;
    do
        for i in ${!dirs[*]};
        do
            dir=${dirs[i]};
            if [[ ! -d $dir ]]; then
                unset -v 'dirs[i]';
                continue;
            fi;
            for compfile in "$prefix$cmdname" "$prefix$cmdname.bash";
            do
                compfile="$dir/$compfile";
                if [[ -d $compfile ]]; then
                    [[ $compfile == */.?(.) ]] || echo "bash_completion: $compfile: is a directory" 1>&2;
                else
                    if [[ -e $compfile ]] && . "$compfile" "$cmd" "$@"; then
                        if compspec=$(complete -p -- "$cmd" 2> /dev/null); then
                            [[ -n $backslash ]] && eval "$compspec \"\$backslash\$cmd\"";
                            [[ $origcmd != */* ]] && ! complete -p -- "$origcmd" &> /dev/null && eval "$compspec \"\$origcmd\"";
                            return 0;
                        fi;
                        if [[ $cmdname != "$cmd" ]] && compspec=$(complete -p -- "$cmdname" 2> /dev/null); then
                            [[ $cmd == /* ]] && eval "$compspec \"\$cmd\"";
                            return 0;
                        fi;
                    fi;
                fi;
            done;
        done;
    done;
    [[ -v _comp_xspecs[$cmdname] || -v _xspecs[$cmdname] ]] && complete -F _comp_complete_filedir_xspec "$cmdname" "$backslash$cmdname" && return 0;
    if [[ -n $flag_fallback_default ]]; then
        complete -F _comp_complete_minimal -- "$origcmd" && return 0;
    fi;
    return 1
}
_comp_locate_first_arg () 
{ 
    local has_optarg="";
    local OPTIND=1 OPTARG="" OPTERR=0 _opt;
    while getopts ':a:' _opt "$@"; do
        case $_opt in 
            a)
                has_optarg=$OPTARG
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 2
            ;;
        esac;
    done;
    shift "$((OPTIND - 1))";
    local i;
    REPLY=;
    for ((i = 1; i < cword; i++))
    do
        if [[ -n $has_optarg && ${words[i]} == $has_optarg ]]; then
            ((i++));
        else
            if [[ ${words[i]} != -?* ]]; then
                REPLY=$i;
                return 0;
            else
                if [[ ${words[i]} == -- ]]; then
                    ((i + 1 < cword)) && REPLY=$((i + 1)) && return 0;
                    break;
                fi;
            fi;
        fi;
    done;
    return 1
}
_comp_looks_like_path () 
{ 
    [[ ${1-} == @(*/|[.~])* ]]
}
_comp_ltrim_colon_completions () 
{ 
    ((${#COMPREPLY[@]})) || return 0;
    _comp_compgen -c "$1" ltrim_colon "${COMPREPLY[@]}"
}
_comp_quote () 
{ 
    REPLY=\'${1//\'/\'\\\'\'}\'
}
_comp_quote_compgen () 
{ 
    if [[ $1 == \'* ]]; then
        REPLY=${1:1};
    else
        printf -v REPLY %q "$1";
        if [[ $REPLY == \$\'*\' ]]; then
            local value=${REPLY:2:-1};
            value=${value//'%'/%%};
            printf -v REPLY "$value";
        fi;
    fi
}
_comp_readline_variable_on () 
{ 
    [[ $(bind -v) == *$1+([[:space:]])on* ]]
}
_comp_realcommand () 
{ 
    REPLY="";
    local file;
    file=$(type -P -- "$1") || return $?;
    if type -p realpath > /dev/null; then
        REPLY=$(realpath "$file");
    else
        if type -p greadlink > /dev/null; then
            REPLY=$(greadlink -f "$file");
        else
            if type -p readlink > /dev/null; then
                REPLY=$(readlink -f "$file");
            else
                _comp_abspath "$file";
            fi;
        fi;
    fi
}
_comp_root_command () 
{ 
    local PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin;
    local _comp_root_command=$1;
    _comp_command
}
_comp_split () 
{ 
    local _append="" IFS=' 	
';
    local OPTIND=1 OPTARG="" OPTERR=0 _opt;
    while getopts ':alF:' _opt "$@"; do
        case $_opt in 
            a)
                _append=set
            ;;
            l)
                IFS='
'
            ;;
            F)
                IFS=$OPTARG
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 2
            ;;
        esac;
    done;
    shift "$((OPTIND - 1))";
    if (($# != 2)); then
        printf '%s\n' "bash_completion: $FUNCNAME: unexpected number of arguments" 1>&2;
        printf '%s\n' "usage: $FUNCNAME [-al] [-F SEP] ARRAY_NAME TEXT" 1>&2;
        return 2;
    else
        if [[ $1 == @(*[^_a-zA-Z0-9]*|[0-9]*|''|_*|IFS|OPTIND|OPTARG|OPTERR) ]]; then
            printf '%s\n' "bash_completion: $FUNCNAME: invalid array name '$1'" 1>&2;
            return 2;
        fi;
    fi;
    local _original_opts=$SHELLOPTS;
    set -o noglob;
    local _old_size _new_size;
    if [[ -n $_append ]]; then
        eval "$1+=()";
        eval "_old_size=\${#$1[@]}";
        eval "$1+=(\$2)";
    else
        _old_size=0;
        eval "$1=(\$2)";
    fi;
    eval "_new_size=\${#$1[@]}";
    [[ :$_original_opts: == *:noglob:* ]] || set +o noglob;
    ((_new_size > _old_size))
}
_comp_sysvdirs () 
{ 
    sysvdirs=();
    [[ -d /etc/rc.d/init.d ]] && sysvdirs+=(/etc/rc.d/init.d);
    [[ -d /etc/init.d ]] && sysvdirs+=(/etc/init.d);
    [[ -f /etc/slackware-version ]] && sysvdirs=(/etc/rc.d);
    ((${#sysvdirs[@]}))
}
_comp_try_faketty () 
{ 
    if type unbuffer &> /dev/null; then
        unbuffer -p "$@";
    else
        if script --version 2>&1 | command grep -qF util-linux; then
            script -qaefc "$*" /dev/null;
        else
            "$@";
        fi;
    fi
}
_comp_unlocal () 
{ 
    if ((BASH_VERSINFO[0] >= 5)) && shopt -q localvar_unset; then
        shopt -u localvar_unset;
        unset -v "$@";
        shopt -s localvar_unset;
    else
        unset -v "$@";
    fi
}
_comp_upvars () 
{ 
    if ! (($#)); then
        echo "bash_completion: $FUNCNAME: usage: $FUNCNAME" "[-v varname value] | [-aN varname [value ...]] ..." 1>&2;
        return 2;
    fi;
    while (($#)); do
        case $1 in 
            -a*)
                [[ -n ${1#-a} ]] || { 
                    echo "bash_completion: $FUNCNAME:" "\`$1': missing number specifier" 1>&2;
                    return 1
                };
                printf %d "${1#-a}" &> /dev/null || { 
                    echo bash_completion: "$FUNCNAME: \`$1': invalid number specifier" 1>&2;
                    return 1
                };
                [[ -n $2 ]] && unset -v "$2" && eval "$2"=\(\"\$"{@:3:${1#-a}}"\"\) && shift $((${1#-a} + 2)) || { 
                    echo bash_completion: "$FUNCNAME: \`$1${2+ }$2': missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            -v)
                [[ -n $2 ]] && unset -v "$2" && eval "$2"=\"\$3\" && shift 3 || { 
                    echo "bash_completion: $FUNCNAME: $1:" "missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            *)
                echo "bash_completion: $FUNCNAME: $1: invalid option" 1>&2;
                return 1
            ;;
        esac;
    done
}
_comp_userland () 
{ 
    local userland=$(uname -s);
    [[ $userland == @(Linux|GNU/*) ]] && userland=GNU;
    [[ $userland == "$1" ]]
}
_comp_variable_assignments () 
{ 
    local cur=${1-} i;
    if [[ $cur =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
        prev=${BASH_REMATCH[1]};
        cur=${BASH_REMATCH[2]};
    else
        return 1;
    fi;
    case $prev in 
        TZ)
            cur=/usr/share/zoneinfo/$cur;
            _comp_compgen_filedir;
            if ((${#COMPREPLY[@]})); then
                for i in "${!COMPREPLY[@]}";
                do
                    if [[ ${COMPREPLY[i]} == *.tab ]]; then
                        unset -v 'COMPREPLY[i]';
                        continue;
                    else
                        if [[ -d ${COMPREPLY[i]} ]]; then
                            COMPREPLY[i]+=/;
                            compopt -o nospace;
                        fi;
                    fi;
                    COMPREPLY[i]=${COMPREPLY[i]#/usr/share/zoneinfo/};
                done;
            fi
        ;;
        TERM)
            _comp_compgen_terms
        ;;
        LANG | LC_*)
            _comp_compgen_split -- "$(locale -a 2> /dev/null)"
        ;;
        LANGUAGE)
            _comp_delimited : -W '$(locale -a 2>/dev/null)'
        ;;
        *)
            _comp_compgen_variables && return 0;
            _comp_compgen -a filedir
        ;;
    esac;
    return 0
}
_comp_xfunc () 
{ 
    local xfunc_name=$2;
    [[ $xfunc_name == _* ]] || xfunc_name=_comp_xfunc_${1//[^a-zA-Z0-9_]/_}_$xfunc_name;
    declare -F -- "$xfunc_name" &> /dev/null || _comp_load -- "$1";
    "$xfunc_name" "${@:3}"
}
_complete_as_root () 
{ 
    _comp_as_root "$@"
}
_completion_loader () 
{ 
    _comp_complete_load "$@"
}
_configured_interfaces () 
{ 
    _comp_compgen_configured_interfaces "$@"
}
_count_args () 
{ 
    local i cword words;
    _comp__reassemble_words "${1-}" words cword;
    args=1;
    for ((i = 1; i < cword; i++))
    do
        if [[ ${words[i]} != -* && ${words[i - 1]} != ${2-} || ${words[i]} == ${3-} ]]; then
            ((args++));
        fi;
    done
}
_dvd_devices () 
{ 
    _comp_compgen -a dvd_devices
}
_expand () 
{ 
    _comp_expand "$@"
}
_filedir () 
{ 
    _comp_compgen -a filedir "$@"
}
_filedir_xspec () 
{ 
    _comp_complete_filedir_xspec "$@"
}
_fstypes () 
{ 
    _comp_compgen -a fstypes
}
_get_comp_words_by_ref () 
{ 
    _comp_get_words "$@"
}
_get_cword () 
{ 
    local LC_CTYPE=C;
    local cword words;
    _comp__reassemble_words "${1-}" words cword;
    if [[ -n ${2-} && -n ${2//[^0-9]/} ]]; then
        printf "%s" "${words[cword - $2]}";
    else
        if ((${#words[cword]} == 0 && COMP_POINT == ${#COMP_LINE})); then
            :;
        else
            local i;
            local cur=$COMP_LINE;
            local index=$COMP_POINT;
            for ((i = 0; i <= cword; ++i))
            do
                while [[ ${#cur} -ge ${#words[i]} && ${cur:0:${#words[i]}} != "${words[i]}" ]]; do
                    cur=${cur:1};
                    ((index > 0)) && ((index--));
                done;
                if ((i < cword)); then
                    local old_size=${#cur};
                    cur=${cur#"${words[i]}"};
                    local new_size=${#cur};
                    ((index -= old_size - new_size));
                fi;
            done;
            if [[ ${words[cword]:0:${#cur}} != "$cur" ]]; then
                printf "%s" "${words[cword]}";
            else
                printf "%s" "${cur:0:index}";
            fi;
        fi;
    fi
}
_get_first_arg () 
{ 
    local i;
    arg=;
    for ((i = 1; i < COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            arg=${COMP_WORDS[i]};
            break;
        fi;
    done
}
_get_pword () 
{ 
    if ((COMP_CWORD >= 1)); then
        _get_cword "${@-}" 1;
    fi
}
_gids () 
{ 
    _comp_compgen_gids "$@"
}
_gluster_completion () 
{ 
    GLUSTER_FINAL_LIST=`echo $GLUSTER_COMMAND_TREE |                                      egrep -ao --color=never "([A-Za-z0-9_.-]+)|[[:space:]]+|." |                          egrep -v --color=never "^[[:space:]]*$" |                                             _gluster_parse`;
    ARG="GLUSTER_FINAL_LIST";
    _gluster_handle_list $ARG ${COMP_WORDS[COMP_CWORD]};
    return
}
_gluster_does_match () 
{ 
    local token="$1";
    local key="$2";
    if [ "${token:0:1}" == "_" ]; then
        $token $2;
        return $?;
    fi;
    [ "$token" == "$key" ] && return 0;
    return 1
}
_gluster_form_list () 
{ 
    local token='';
    local top=0;
    local comma='';
    local cur_word="$1";
    read -r token;
    case $token in 
        ']')

        ;;
        '{')
            _gluster_push;
            top=$?;
            read -r key;
            if [ "X$cur_word" == "X" -o "${cur_word:0:1}" == "${key:0:1}" -o "${key:0:1}" == "_" ]; then
                GLUSTER_LIST="$GLUSTER_LIST $key";
            fi;
            _gluster_goto_end $top;
            read -r comma;
            if [ "$comma" == "," ]; then
                _gluster_form_list $cur_word;
            fi
        ;;
        *)
            _gluster_throw "Expected '{' but received $token"
        ;;
    esac;
    return
}
_gluster_goto_child () 
{ 
    local match_string="$1";
    local token='';
    local top=0;
    local comma='';
    read -r token;
    case $token in 
        '{')
            _gluster_push;
            top=$?
        ;;
        *)
            _gluster_throw "Expected '{' but received $token"
        ;;
    esac;
    read -r token;
    case `echo $token` in 
        '[' | ']' | '{' | '}')
            _gluster_throw "Expected string but received $token"
        ;;
        _*)
            $token "match" $match_string;
            ret=$?;
            if [ $ret -eq 0 ]; then
                return;
            else
                _gluster_goto_end $top;
                read -r comma;
                if [ "$comma" == "," ]; then
                    _gluster_goto_child $match_string;
                fi;
            fi
        ;;
        "$match_string")
            return
        ;;
        *)
            _gluster_goto_end $top;
            read -r comma;
            if [ "$comma" == "," ]; then
                _gluster_goto_child $match_string;
            fi
        ;;
    esac;
    return
}
_gluster_goto_end () 
{ 
    local prev_top=$1;
    local top=$1;
    local token='';
    while [ $top -ge $prev_top ]; do
        read -r token;
        case $token in 
            '{' | '[')
                _gluster_push;
                top=$?
            ;;
            '}' | ']')
                _gluster_pop;
                top=$?
            ;;
        esac;
    done;
    return
}
_gluster_handle_list () 
{ 
    local list="${!1}";
    local cur_word=$2;
    local count=0;
    local i=0;
    local res="";
    for i in `echo $list`;
    do
        if [ "${i:0:1}" == "_" ]; then
            $i "complete" $cur_word;
            res="$res $func_return";
        else
            res="$res $i";
        fi;
    done;
    COMPREPLY=($(compgen -W "$res" -- $cur_word));
    return
}
_gluster_parse () 
{ 
    local i=0;
    local token='';
    local tmp_token='';
    local word='';
    while [ $i -lt $COMP_CWORD ]; do
        read -r token;
        case $token in 
            '[')
                _gluster_push;
                _gluster_goto_child ${COMP_WORDS[$i]}
            ;;
            '{')
                _gluster_push;
                read -r tmp_token;
                _gluster_does_match $tmp_token ${COMP_WORDS[$i]};
                if [ $? -ne 0 ]; then
                    _gluster_throw "No match";
                fi
            ;;
        esac;
        i=$((i+1));
    done;
    read -r token;
    if [ "$token" == '[' ]; then
        _gluster_push;
        _gluster_form_list ${COMP_WORDS[COMP_CWORD]};
    else
        if [ "$token" == '{' ]; then
            read -r tmp_token;
            GLUSTER_LIST="$tmp_token";
        fi;
    fi;
    echo $GLUSTER_LIST
}
_gluster_pop () 
{ 
    GLUSTER_TOP=$((GLUSTER_TOP - 1));
    return $GLUSTER_TOP
}
_gluster_push () 
{ 
    GLUSTER_TOP=$((GLUSTER_TOP + 1));
    return $GLUSTER_TOP
}
_gluster_throw () 
{ 
    COMPREPLY='';
    exit
}
_have () 
{ 
    _comp_have_command "$@"
}
_init_completion () 
{ 
    local was_split;
    _comp_initialize "$@";
    local rc=$?;
    local flag OPTIND=1 OPTARG="" OPTERR=0;
    while getopts "n:e:o:i:s" flag "$@"; do
        case $flag in 
            [neoi])

            ;;
            s)
                if [[ -n $was_split ]]; then
                    split=true;
                else
                    split=false;
                fi;
                break
            ;;
        esac;
    done;
    return "$rc"
}
_installed_modules () 
{ 
    _comp_compgen_inserted_kernel_modules "$@"
}
_ip_addresses () 
{ 
    _comp_compgen_ip_addresses "$@"
}
_kernel_versions () 
{ 
    _comp_compgen_kernel_versions "$@"
}
_known_hosts () 
{ 
    _comp_complete_known_hosts "$@"
}
_known_hosts_real () 
{ 
    _comp_compgen_known_hosts "$@"
}
_longopt () 
{ 
    _comp_complete_longopt "$@"
}
_mac_addresses () 
{ 
    _comp_compgen_mac_addresses "$@"
}
_minimal () 
{ 
    _comp_complete_minimal "$@"
}
_modules () 
{ 
    _comp_compgen_kernel_modules "$@"
}
_ncpus () 
{ 
    local REPLY;
    _comp_get_ncpus;
    printf %s "$REPLY"
}
_parse_help () 
{ 
    local -a args;
    if [[ $1 == - ]]; then
        args=(-);
    else
        local REPLY opt IFS=' 	
';
        _comp_dequote "$1";
        _comp_split opt "${2:---help}";
        args=(-c "$REPLY" ${opt[@]+"${opt[@]}"});
    fi;
    local -a REPLY=();
    _comp_compgen -Rv REPLY help "${args[@]}" || return 1;
    ((${#REPLY[@]})) && printf '%s\n' "${REPLY[@]}";
    return 0
}
_parse_usage () 
{ 
    local -a args;
    if [[ $1 == - ]]; then
        args=(-);
    else
        local REPLY opt IFS=' 	
';
        _comp_dequote "$1";
        _comp_split opt "${2:---usage}";
        args=(-c "$REPLY" ${opt[@]+"${opt[@]}"});
    fi;
    local -a REPLY=();
    _comp_compgen -Rv REPLY usage "${args[@]}" || return 1;
    ((${#REPLY[@]})) && printf '%s\n' "${REPLY[@]}";
    return 0
}
_pci_ids () 
{ 
    _comp_compgen -a pci_ids
}
_pgids () 
{ 
    _comp_compgen_pgids "$@"
}
_pids () 
{ 
    _comp_compgen_pids "$@"
}
_pnames () 
{ 
    _comp_compgen_pnames "$@"
}
_quote_readline_by_ref () 
{ 
    [[ $2 == REPLY ]] || local REPLY;
    _comp_quote_compgen "$1";
    [[ $2 == REPLY ]] || printf -v "$2" %s "$REPLY"
}
_realcommand () 
{ 
    local REPLY;
    _comp_realcommand "$1";
    local rc=$?;
    printf "%s\n" "$REPLY";
    return $rc
}
_rl_enabled () 
{ 
    _comp_readline_variable_on "$@"
}
_root_command () 
{ 
    _comp_root_command "$@"
}
_service () 
{ 
    _comp_complete_service "$@"
}
_services () 
{ 
    _comp_compgen_services "$@"
}
_shells () 
{ 
    _comp_compgen -a shells
}
_signals () 
{ 
    _comp_compgen_signals "$@"
}
_sysvdirs () 
{ 
    _comp_sysvdirs "$@"
}
_terms () 
{ 
    _comp_compgen -a terms
}
_tilde () 
{ 
    ! _comp_compgen -c "$1" tilde
}
_uids () 
{ 
    _comp_compgen_uids "$@"
}
_upvar () 
{ 
    echo "bash_completion: $FUNCNAME: deprecated function," "use _comp_upvars instead" 1>&2;
    if unset -v "$1"; then
        if (($# == 2)); then
            eval "$1"=\"\$2\";
        else
            eval "$1"=\(\"\$"{@:2}"\"\);
        fi;
    fi
}
_upvars () 
{ 
    _comp_upvars "$@"
}
_usb_ids () 
{ 
    _comp_compgen -a usb_ids
}
_user_at_host () 
{ 
    _comp_complete_user_at_host "$@"
}
_usergroup () 
{ 
    _comp_compgen_usergroups "$@"
}
_userland () 
{ 
    _comp_userland "$@"
}
_variables () 
{ 
    _comp_compgen_variables "$@"
}
_xfunc () 
{ 
    _comp_xfunc "$@"
}
_xinetd_services () 
{ 
    _comp_compgen_xinetd_services "$@"
}
dequote () 
{ 
    local REPLY;
    _comp_dequote "$1";
    local rc=$?;
    printf %s "$REPLY";
    return $rc
}
fuck () 
{ 
    TF_PYTHONIOENCODING=$PYTHONIOENCODING;
    export TF_SHELL=bash;
    export TF_ALIAS=fuck;
    export TF_SHELL_ALIASES=$(alias);
    export TF_HISTORY=$(fc -ln -10);
    export PYTHONIOENCODING=utf-8;
    TF_CMD=$(thefuck THEFUCK_ARGUMENT_PLACEHOLDER "$@") && eval "$TF_CMD";
    unset TF_HISTORY;
    export PYTHONIOENCODING=$TF_PYTHONIOENCODING;
    history -s $TF_CMD
}
husband () 
{ 
    ( COLORS_LIGHT_PINK='\e[38;5;217m';
    COLORS_LIGHT_BLUE='\e[38;5;117m';
    COLORS_FAINT='\e[2m';
    COLORS_RESET='\e[0m';
    DEF_WORDS_LITTLE="girl";
    DEF_WORDS_PRONOUNS="her";
    DEF_WORDS_ROLES="mommy";
    DEF_MOMMY_COLOR="${COLORS_LIGHT_PINK}";
    DEF_ONLY_NEGATIVE="false";
    NEGATIVE_RESPONSES="do you need MOMMYS_ROLE's help~? 
Don't give up, my love~ 
Don't worry, MOMMYS_ROLE is here to help you~ 
I believe in you, my sweet AFFECTIONATE_TERM~ 
It's okay to make mistakes, my dear~ 
just a little further, sweetie~ 
Let's try again together, okay~? 
MOMMYS_ROLE believes in you, and knows you can overcome this~ 
MOMMYS_ROLE believes in you~ 
MOMMYS_ROLE is always here for you, no matter what~ 
MOMMYS_ROLE is here to help you through it~ 
MOMMYS_ROLE is proud of you for trying, no matter what the outcome~ 
MOMMYS_ROLE knows it's tough, but you can do it~ 
MOMMYS_ROLE knows MOMMYS_PRONOUN little AFFECTIONATE_TERM can do better~ 
MOMMYS_ROLE knows you can do it, even if it's tough~ 
MOMMYS_ROLE knows you're feeling down, but you'll get through it~ 
MOMMYS_ROLE knows you're trying your best~ 
MOMMYS_ROLE loves you, and is here to support you~ 
MOMMYS_ROLE still loves you no matter what~ 
You're doing your best, and that's all that matters to MOMMYS_ROLE~ 
MOMMYS_ROLE is always here to encourage you~ ";
    POSITIVE_RESPONSES="*pets your head*
awe, what a good AFFECTIONATE_TERM~\nMOMMYS_ROLE knew you could do it~ 
good AFFECTIONATE_TERM~\nMOMMYS_ROLE's so proud of you~ 
Keep up the good work, my love~ 
MOMMYS_ROLE is proud of the progress you've made~ 
MOMMYS_ROLE is so grateful to have you as MOMMYS_PRONOUN little AFFECTIONATE_TERM~ 
I'm so proud of you, my love~ 
MOMMYS_ROLE is so proud of you~ 
MOMMYS_ROLE loves seeing MOMMYS_PRONOUN little AFFECTIONATE_TERM succeed~ 
MOMMYS_ROLE thinks MOMMYS_PRONOUN little AFFECTIONATE_TERM earned a big hug~ 
that's a good AFFECTIONATE_TERM~ 
you did an amazing job, my dear~ 
you're such a smart cookie~ ";
    if [ -n "$SHELL_MOMMYS_LITTLE" ]; then
        DEF_WORDS_LITTLE="${SHELL_MOMMYS_LITTLE}";
    fi;
    if [ -n "$SHELL_MOMMYS_PRONOUNS" ]; then
        DEF_WORDS_PRONOUNS="${SHELL_MOMMYS_PRONOUNS}";
    fi;
    if [ -n "$SHELL_MOMMYS_ROLES" ]; then
        DEF_WORDS_ROLES="${SHELL_MOMMYS_ROLES}";
    fi;
    if [ -n "$SHELL_MOMMYS_COLOR" ]; then
        DEF_MOMMY_COLOR="${SHELL_MOMMYS_COLOR}";
    fi;
    if [ "$SHELL_MOMMYS_ONLY_NEGATIVE" = "true" ]; then
        DEF_ONLY_NEGATIVE="true";
    fi;
    if [ -n "$SHELL_MOMMYS_POSITIVE_RESPONSES" ]; then
        POSITIVE_RESPONSES="$SHELL_MOMMYS_POSITIVE_RESPONSES";
    fi;
    if [ -n "$SHELL_MOMMYS_NEGATIVE_RESPONSES" ]; then
        NEGATIVE_RESPONSES="$SHELL_MOMMYS_NEGATIVE_RESPONSES";
    fi;
    function pick_word () 
    { 
        echo "$1" | tr '/' '\n' | shuf | sed 1q
    };
    function pick_response () 
    { 
        if [ "$1" = "positive" ]; then
            element=$(echo "$POSITIVE_RESPONSES" | shuf | sed 1q);
        else
            if [ "$1" = "negative" ]; then
                element=$(echo "$NEGATIVE_RESPONSES" | shuf | sed 1q);
            else
                echo "Invalid response type: $1";
                exit 1;
            fi;
        fi;
        echo "$element"
    };
    function sub_terms () 
    { 
        response="$1";
        affectionate_term="$(pick_word "${DEF_WORDS_LITTLE}")";
        pronoun="$(pick_word "${DEF_WORDS_PRONOUNS}")";
        role="$(pick_word "${DEF_WORDS_ROLES}")";
        response="$(echo "$response" | sed "s/AFFECTIONATE_TERM/$affectionate_term/g")";
        response="$(echo "$response" | sed "s/MOMMYS_PRONOUN/$pronoun/g")";
        response="$(echo "$response" | sed "s/MOMMYS_ROLE/$role/g")";
        printf "${DEF_MOMMY_COLOR}$response${COLORS_RESET}\n"
    };
    function success () 
    { 
        ( if [ "$DEF_ONLY_NEGATIVE" = "true" ]; then
            return 0;
        fi;
        response="$(pick_response "positive")";
        sub_terms "$response" 1>&2 );
        return 0
    };
    function failure () 
    { 
        rc=$?;
        ( response="$(pick_response "negative")";
        sub_terms "$response" 1>&2 );
        return $rc
    };
    eval "$@" && success || failure;
    return $? )
}
quote () 
{ 
    local quoted=${1//\'/\'\\\'\'};
    printf "'%s'" "$quoted"
}
quote_readline () 
{ 
    local REPLY;
    _comp_quote_compgen "$1";
    printf %s "$REPLY"
}
